<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>绿萝间 (Parallel Programming with Python)</title><link>http://muxuezi.github.io/</link><description></description><atom:link href="http://muxuezi.github.io/categories/parallel-programming-with-python.xml" type="application/rss+xml" rel="self"></atom:link><language>en</language><lastBuildDate>Mon, 28 Sep 2015 13:12:55 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>4.Using the threading and concurrent.futures Modules</title><link>http://muxuezi.github.io/posts/4using-the-threading-and-concurrentfutures-modules.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="4.用threading和concurrent.futures模块"&gt;4.用&lt;code&gt;threading&lt;/code&gt;和&lt;code&gt;concurrent.futures&lt;/code&gt;模块&lt;a class="anchor-link" href="http://muxuezi.github.io/posts/4using-the-threading-and-concurrentfutures-modules.html#4.%E7%94%A8threading%E5%92%8Cconcurrent.futures%E6%A8%A1%E5%9D%97"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在上一章，我们总结了并行思想可以解决的一些问题。这一章，我们将用Python的&lt;code&gt;threading&lt;/code&gt;模块实现每个问题的解决方案。&lt;/p&gt;
&lt;p&gt;本章内容包括以下主题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程的定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;threading&lt;/code&gt;和&lt;code&gt;_thread&lt;/code&gt;的选择&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;threading&lt;/code&gt;实现多请求的Fibonacci数列&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;concurrent.futures&lt;/code&gt;模块实现网络爬虫&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="线程的定义"&gt;线程的定义&lt;a class="anchor-link" href="http://muxuezi.github.io/posts/4using-the-threading-and-concurrentfutures-modules.html#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"&gt;¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;线程（thread）是一个进程（process）中不同执行单元（execution line）。如果把一个程序比喻成蜂巢（hive），那么向蜂巢里收集花粉（pollen）这件事就是一个进程。这个收集花粉的进程是由若干只为了解决花粉不足问题的工蜂（worker bee）同时工作来完成。这些工蜂扮演的角色就是线程，在进程内部执行并共享资源以完成各自的任务。&lt;/p&gt;
&lt;p&gt;线程属于同一个进程并共享同一块内存。因此，开发者的任务就是控制和使用这块内存。&lt;/p&gt;
&lt;h4 id="使用线程的优缺点"&gt;使用线程的优缺点&lt;a class="anchor-link" href="http://muxuezi.github.io/posts/4using-the-threading-and-concurrentfutures-modules.html#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"&gt;¶&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;使用线程之前，需要考虑线程具有的一些优缺点，而且线程与具体的编程语言和操作系统有密切关联。&lt;/p&gt;
&lt;p&gt;线程的优点主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程在同一个进程内的通信速度，数据定位速度，和信息共享速度都是非常快的&lt;/li&gt;
&lt;li&gt;创建线程的成本比创建进程低，因为它不需要复制主进程上下文所包含的全部信息&lt;/li&gt;
&lt;li&gt;通过处理器缓存优化内存接入速度可以高效使用数据局部存储（data locality，thread local storage，TLS）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程的缺点主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据共享允许快速通信。但是，有时会让经验不足的开发者犯错。&lt;/li&gt;
&lt;li&gt;数据共享限制了解决方案的灵活性。比如，迁移到分布性架构时，线程是十分令人头疼的事情。通常，线程会限制算法的扩展性。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;&lt;p&gt;在Python程序语言里，由于GIL的存在，使用带有CPU限制的线程可能影响程序的性能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="线程类型"&gt;线程类型&lt;a class="anchor-link" href="http://muxuezi.github.io/posts/4using-the-threading-and-concurrentfutures-modules.html#%E7%BA%BF%E7%A8%8B%E7%B1%BB%E5%9E%8B"&gt;¶&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;用两种线程：内核线程（kernel thread）与用户线程（user thread）。内核线程是由操作系统创建和管理的线程。线程上下文的切换（Context Switch），调度，和结束都是通过操作系统的内核管理的。而用户线程的所有状态是由开发者控制的。&lt;/p&gt;
&lt;p&gt;我们可以对比两者的优缺点。&lt;/p&gt;
&lt;p&gt;内核线程的优点主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个内核线程常只轻量进程（lightweight processes）。因此如果一个内核线程阻塞，其他内核线程还可以运行&lt;/li&gt;
&lt;li&gt;内核线程可以在不同的CPU上运行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核线程的缺点主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建与同步操作开销都较大&lt;/li&gt;
&lt;li&gt;实现方式与平台有关&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户线程的优点主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建与同步操作开销都较小&lt;/li&gt;
&lt;li&gt;实现方式与平台无关&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户线程的缺点主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个进程内的所有用户线程只能与一个内核线程关联。因此，如果一个用户线程阻塞，其他用户线程都不能执行&lt;/li&gt;
&lt;li&gt;用户线程不运行在不同的CPU上&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="线程状态定义"&gt;线程状态定义&lt;a class="anchor-link" href="http://muxuezi.github.io/posts/4using-the-threading-and-concurrentfutures-modules.html#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%AE%9A%E4%B9%89"&gt;¶&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;线程生命周期中一共五个状态，如下所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建&lt;/strong&gt;：主进程创建一个线程，创建之后，会被发送到线程队列准备执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行&lt;/strong&gt;：这个阶段，线程使用CPU&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;就绪&lt;/strong&gt;：这个阶段，线程在线程队列里准备就绪即将执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阻塞&lt;/strong&gt;：这个阶段，线程被阻塞，可能是等待I/O操作完成，这个阶段不使用CPU&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结束&lt;/strong&gt;：这个阶段，释放执行时占用的资源，结束线程的生命周期&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="threading和_thread的选择"&gt;&lt;code&gt;threading&lt;/code&gt;和&lt;code&gt;_thread&lt;/code&gt;的选择&lt;a class="anchor-link" href="http://muxuezi.github.io/posts/4using-the-threading-and-concurrentfutures-modules.html#threading%E5%92%8C_thread%E7%9A%84%E9%80%89%E6%8B%A9"&gt;¶&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Python标准库里提供了两个线程模块：&lt;code&gt;_thread&lt;/code&gt;模块（这个Python模块提供了一个线程的底层API，具体文档见&lt;em&gt;&lt;code&gt;https://docs.python.org/3.5/library/_thread.html#module-_thread&lt;/code&gt;&lt;/em&gt;）和&lt;code&gt;threading&lt;/code&gt;模块（这个Python模块提供了一个线程的高层API，具体文档见&lt;em&gt;&lt;code&gt;https://docs.python.org/3.5/library/threading.html#module-threading&lt;/code&gt;&lt;/em&gt;）。这个&lt;code&gt;threading&lt;/code&gt;模块通过了比&lt;code&gt;_thread&lt;/code&gt;模块更友好的接口，使用起来更方便。开发者根据自己口味选择。如果开发者觉得用线程的底层API更舒服，可以实现自己的线程池（thread pool），互斥锁和其他原始特征，那么他可以选择&lt;code&gt;_thread&lt;/code&gt;模块。否则，还是用&lt;code&gt;threading&lt;/code&gt;模块最方便。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h3 id="用threading实现多请求的Fibonacci数列"&gt;用&lt;code&gt;threading&lt;/code&gt;实现多请求的Fibonacci数列&lt;a class="anchor-link" href="http://muxuezi.github.io/posts/4using-the-threading-and-concurrentfutures-modules.html#%E7%94%A8threading%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%AF%B7%E6%B1%82%E7%9A%84Fibonacci%E6%95%B0%E5%88%97"&gt;¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;现在是时候回到现实。我们的任务是在Fibonacci数列有多个输入请求时并行的执行。处于教学的目的，我们把输入值设置成四个，每个输入值分配一个线程运行函数，让worker与要执行的任务（task）完美地一一对应。算法如下所示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先，用列表储存需要计算的四个值，然后把值发送到一个允许线程同步使用的结构中。&lt;/li&gt;
&lt;li&gt;当等待计算的值被发送到可同步使用的结构中之后，计算Fibonacci数列的线程需要一个信号告诉它们数据已经准备就绪了。我们用一个叫&lt;code&gt;Condition&lt;/code&gt;的线程同步机制（Thread synchronization mechanism）。（&lt;code&gt;Condition&lt;/code&gt;机制是一个Python对象，用来提供多个线程之间数据使用的同步机制，具体文档查看&lt;em&gt;&lt;code&gt;https://docs.python.org/3/library/threading.html#condition-objects&lt;/code&gt;&lt;/em&gt;。）&lt;/li&gt;
&lt;li&gt;当每个线程完成对应Fibonacci数列的计算之后，把结果保存到词典中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么，现在让我们演示最有趣的代码和注释内容。&lt;/p&gt;
&lt;p&gt;代码开始的时候，我们使用Unicode编码格式，然后导入&lt;code&gt;logging&lt;/code&gt;，&lt;code&gt;threading&lt;/code&gt;和&lt;code&gt;Queue&lt;/code&gt;模块。另外，我们在例子中已经定义了主要的数据结构。我们定义了一个字典&lt;code&gt;fibo_dict&lt;/code&gt;，把每个整数（作为用户输入）存储为键，对应Fibonacci数列的计算作为字典的值。我们还用&lt;code&gt;queue&lt;/code&gt;模块中的&lt;code&gt;Queue&lt;/code&gt;模块声明了一个&lt;code&gt;Queue&lt;/code&gt;对象&lt;code&gt;shared_queue&lt;/code&gt;，用来存储计算Fibonacci数列线程之间的共享数据，线程把数据插入&lt;code&gt;Queue&lt;/code&gt;对象。最后，我们定义最后一个数据结构——一个带四个元素的Python的&lt;code&gt;list&lt;/code&gt;对象，模拟程序即将接收到的值。代码如下所示：&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span class="c"&gt;#coding: utf-8&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;threading&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;queue&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Queue&lt;/span&gt;

&lt;span class="n"&gt;logger&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getLogger&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setLevel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DEBUG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;formatter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Formatter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'%(asctime)s - %(message)s'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StreamHandler&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setLevel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DEBUG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setFormatter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;formatter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;fibo_dict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="n"&gt;shared_queue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Queue&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;input_list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;下载源代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以在Packt网站&lt;em&gt;&lt;code&gt;https://www.packtpub.com/&lt;/code&gt;&lt;/em&gt;，用你的账号下载所有书籍的示例代码。如果你从其他地方买的书，你可以先用&lt;em&gt;&lt;code&gt;https://www.packtpub.com/books/content/support&lt;/code&gt;&lt;/em&gt;搜索书籍名称，然后用你的邮箱地址注册一个账号下载代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面一行代码，我们将定义一个&lt;code&gt;threading&lt;/code&gt;模块里的&lt;code&gt;Condition&lt;/code&gt;对象。这个对象可以通过一个具体的条件来同步资源使用的状态。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span class="n"&gt;queue_condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Condition&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;使用&lt;code&gt;Condition&lt;/code&gt;对象是为了控制队列的创建，以及里面发生的过程。&lt;/p&gt;
&lt;p&gt;代码的另一个部分是定义线程即将执行的函数&lt;code&gt;fibonacci_task&lt;/code&gt;。&lt;code&gt;fibonacci_task&lt;/code&gt;函数的参数是&lt;code&gt;condition&lt;/code&gt;对象，用来控制&lt;code&gt;fibonacci_task&lt;/code&gt;使用&lt;code&gt;shared_queue&lt;/code&gt;。我们使用&lt;code&gt;with&lt;/code&gt;语句（关于&lt;code&gt;with&lt;/code&gt;语句更多的信息，请参考&lt;em&gt;&lt;code&gt;https://docs.python.org/3/reference/compound_stmts.html#the-with-statement&lt;/code&gt;&lt;/em&gt;）来简化上下文的形式。如果不使用&lt;code&gt;with&lt;/code&gt;语句，我们就需要显式地对线程锁进行获取和释放。使用&lt;code&gt;with&lt;/code&gt;语句，我们就可以在程序一开始就获取线程锁，然后在程序结束的时候自动退出线程锁。在&lt;code&gt;fibonacci_task&lt;/code&gt;函数的&lt;code&gt;with&lt;/code&gt;语句后面是一个逻辑表达式，告诉当前的线程，“当&lt;code&gt;shared_queue&lt;/code&gt;为空时，一直等待”。等待就是用&lt;code&gt;condition&lt;/code&gt;对象的&lt;code&gt;wait()&lt;/code&gt;方法是实现的。线程会等待，直到它被告知&lt;code&gt;shared_queue&lt;/code&gt;可以使用时才停止。一旦条件得到满足，就会立即计算Fibonacci数列的值并存储到字典&lt;code&gt;fibo_dict&lt;/code&gt;中。最后，我们调用&lt;code&gt;task_done()&lt;/code&gt;方法，确认某一个排队的任务已经被抽取出来执行了。代码如下所示：&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fibonacci_task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;shared_queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
            &lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"[%s] - waiting for elements in queue.."&lt;/span&gt;
                &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current_thread&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shared_queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
                &lt;span class="n"&gt;fibo_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
        &lt;span class="n"&gt;shared_queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;task_done&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"[%s] fibonacci of key [%d] with result [%d]"&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current_thread&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fibo_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;我们定义的第二个函数是&lt;code&gt;queue_task&lt;/code&gt;是由线程执行的，把线程计算的结果添加到&lt;code&gt;shared_queue&lt;/code&gt;里。我们会发现函数把&lt;code&gt;condition&lt;/code&gt;作为线程同步接入&lt;code&gt;shared_queue&lt;/code&gt;队列的参数。线程会把&lt;code&gt;input_list&lt;/code&gt;中的每个元素都存储到&lt;code&gt;shared_queue&lt;/code&gt;队列中。&lt;/p&gt;
&lt;p&gt;当元素都存储到&lt;code&gt;shared_queue&lt;/code&gt;队列之后，函数会告诉线程负责计算Fibonacci数列的队列已经准备好了。这个函数用&lt;code&gt;condition.notifyAll()&lt;/code&gt;完成，如下所示：&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;queue_task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'Starting queue_task...'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;input_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;shared_queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Notifying fibonacci_task threads that the queue is ready to consume.."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;notifyAll&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;在后面的代码里，我们创建一个&lt;code&gt;shared_queue&lt;/code&gt;准备条件已经满足的四线程组。然后我们使用一个允许自定义函数的&lt;code&gt;thread&lt;/code&gt;类构造器（constructor），这个线程将用&lt;code&gt;target&lt;/code&gt;参数设置要执行函数，在&lt;code&gt;args&lt;/code&gt;里面放入要执行函数的参数，如下所示：&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span class="n"&gt;threads&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;daemon&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;fibonacci_task&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                            &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;queue_condition&lt;/span&gt;&lt;span class="p"&gt;,))&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;然后，我们开启准备计算Fibonacci数列的线程。代码如下所示：&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;thread&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;threads&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;紧接着，我们再创建并执行一个控制&lt;code&gt;shared_queue&lt;/code&gt;的线程。代码如下所示：&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span class="n"&gt;prod&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;'queue_task_thread'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;daemon&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                        &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;queue_task&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;queue_condition&lt;/span&gt;&lt;span class="p"&gt;,))&lt;/span&gt;
&lt;span class="n"&gt;prod&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;最后，我们对所有线程调用&lt;code&gt;join()&lt;/code&gt;方法来计算Fibonacci数列。这么做的目的是让&lt;code&gt;main&lt;/code&gt;线程等待这些线程全部执行完Fibonacci数列，这样它就不会在其他线程还没有结束之前就停止。代码如下所示：&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;thread&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;threads&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;程序的执行结果如下图所示：
&lt;img src="http://muxuezi.github.io/posts/ppp/threading_fibonacci.png" alt=""&gt;
可以看出，一开始&lt;code&gt;fibonacci_task&lt;/code&gt;线程被创建并初始化，紧接着进入等待状态。同时，&lt;code&gt;queue_task&lt;/code&gt;被创建，然后生成&lt;code&gt;shared_queue&lt;/code&gt;。最后，&lt;code&gt;queue_task&lt;/code&gt;告诉&lt;code&gt;fibonacci_task&lt;/code&gt;线程可以执行任务了。&lt;/p&gt;
&lt;p&gt;还会看到，&lt;code&gt;fibonacci_task&lt;/code&gt;线程执行并不是自然顺序，每次运行线程执行顺序都会变化。这就是线程的特点：不确定性。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://muxuezi.github.io/posts/ppp/ch4/parallel_fibonacci.py"&gt;源代码&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h3 id="用concurrent.futures模块并行抓取网页"&gt;用&lt;code&gt;concurrent.futures&lt;/code&gt;模块并行抓取网页&lt;a class="anchor-link" href="http://muxuezi.github.io/posts/4using-the-threading-and-concurrentfutures-modules.html#%E7%94%A8concurrent.futures%E6%A8%A1%E5%9D%97%E5%B9%B6%E8%A1%8C%E6%8A%93%E5%8F%96%E7%BD%91%E9%A1%B5"&gt;¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;下面我们将用代码来实现一个并行网络爬虫。这里我们会用一个非常有意思的Python功能，&lt;code&gt;concurrent.futures&lt;/code&gt;模块中的&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;。在前面的例子中，我们用非常原始的线程功能实现了&lt;code&gt;parallel_fibonacci.py&lt;/code&gt;。而且我们是通过手工操作创建和初始化多个线程。在线程较多的项目中，这些做很难管理。通常，都会使用线程池解决线程的状态管理问题。线程池是一种用来保存若干线程的结构，在进程里使用之前创建。其目的是重用线程，这样可以避免重复创建线程——降低资源消耗。&lt;/p&gt;
&lt;p&gt;下面的内容基本和上一节一样，我们需要一个通过多个阶段来执行不同任务的算法，这些任务是彼此相关的。我们将演示并行网络爬虫的代码。&lt;/p&gt;
&lt;p&gt;导入模块并设置日志文件之后，我们用Python的&lt;a href="https://docs.python.org/3/library/re.html#module-re"&gt;&lt;code&gt;re&lt;/code&gt;模块&lt;/a&gt;新建一个正则表达式，我们将在抓取阶段用这个表达式从网页源代码中筛选出所有链接。代码如下所示：&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span class="n"&gt;html_link_regex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'&amp;lt;a\s(?:.*?\s)*?href=[&lt;/span&gt;&lt;span class="se"&gt;\'&lt;/span&gt;&lt;span class="s"&gt;"](.*?)[&lt;/span&gt;&lt;span class="se"&gt;\'&lt;/span&gt;&lt;span class="s"&gt;"].*?&amp;gt;'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;紧接着，我们用一个同步队列来模拟多个输入URL任务。然后，新建一个字典&lt;code&gt;result_dict&lt;/code&gt;来存储结果，把URL和对应页面的链接列表存在字典中。代码如下所示：&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span class="n"&gt;urls&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Queue&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'http://www.sina.com'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'http://cn.bing.com/'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'https://coding.net/'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'http://github.com/'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'http://mail.126.com/'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;result_dict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;之后我们定义一个函数&lt;code&gt;group_urls_task&lt;/code&gt;，从同步队列中抽取URL加入到字典&lt;code&gt;result_dict&lt;/code&gt;里，URL作为字典&lt;code&gt;result_dict&lt;/code&gt;的键。还有一个细节要注意是同步队列的&lt;code&gt;get()&lt;/code&gt;函数用了两个参数。一个参数是&lt;code&gt;True&lt;/code&gt;用来阻塞同步队列接入。另一个参数是&lt;code&gt;0.05&lt;/code&gt;秒，避免在同步队列中没有任务时等待太长时间。有时候，你不会愿意花太多时间阻塞线程来等待任务出现。代码如下所示：&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;group_urls_task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.05&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;result_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;None&lt;/span&gt;
        &lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"[%s] putting url [%s] in dictionary..."&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current_thread&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'Nothing to be done, queue is empty'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;现在，我们用函数&lt;code&gt;crawl_task&lt;/code&gt;实现每个URL的页面的抓取。基本上抓取阶段就是获取URL对应页面上的所有链接。函数返回值是一个元组，第一个元素是URL，第二个元素是URL对应页面上的所有链接构成的列表。这里我们用&lt;a href="http://docs.python-requests.org/en/latest/"&gt;&lt;code&gt;requests&lt;/code&gt;模块&lt;/a&gt;获取URL对应页面的内容。代码如下所示：&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;crawl_task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;links&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;request_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"[%s] crawling url [%s] ..."&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current_thread&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;links&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;html_link_regex&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request_data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exc_info&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="k"&gt;raise&lt;/span&gt;
    &lt;span class="k"&gt;finally&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;links&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;进一步分析代码，我们会看到里面创建了一个&lt;code&gt;concurrent.futures&lt;/code&gt;模块中的&lt;a href="https://docs.python.org/3.5/library/concurrent.futures.html"&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;对象&lt;/a&gt;。在&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;对象的构造器里，设置了&lt;code&gt;max_workers&lt;/code&gt;参数。这个参数在线程池里定义了供执行器（executor）使用的线程数量。在前面将URL从同步队列移除并作为键增加到字典&lt;code&gt;result_dict&lt;/code&gt;这个阶段，都是用这个三个worker线程完成的。这个数量可以根据问题的需要进行设置。完成&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;对象的定义之后，我们用&lt;code&gt;with&lt;/code&gt;语句保证线程的结束例程（ending routine），这些例程将会在&lt;code&gt;with&lt;/code&gt;语句范围结束后立即执行。在&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;对象的范围内，我们在同步队列中重复它，以&lt;code&gt;submit&lt;/code&gt;方法对同步队列中的URL执行一个引用。总之，&lt;code&gt;submit&lt;/code&gt;方法为执行安排了一个可调用函数，然后返回一个带有创建执行的例程安排（scheduling）的&lt;code&gt;Future&lt;/code&gt;对象。&lt;code&gt;submit&lt;/code&gt;方法接收一个可调用函数和函数的参数；在我们的例子里，可调用函数就是&lt;code&gt;group_urls_task&lt;/code&gt;，函数的参数就是同步队列&lt;code&gt;urls&lt;/code&gt;。当这些参数被调用之后，线程池中的worker线程会以一种并行，异步的方式执行函数预订（booking）。代码如下所示：&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;concurrent&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;futures&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_workers&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;group_link_threads&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;qsize&lt;/span&gt;&lt;span class="p"&gt;()):&lt;/span&gt;
        &lt;span class="n"&gt;group_link_threads&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;submit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;group_urls_task&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;之后我们又定义了一个新的&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;对象；但是这一次我们想用前面&lt;code&gt;group_urls_task&lt;/code&gt;函数生成的字典&lt;code&gt;result_dict&lt;/code&gt;的键来执行抓取阶段的任务。代码会有些不同：&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;concurrent&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;futures&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_workers&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;crawler_link_threads&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;future_tasks&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;crawler_link_threads&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;submit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;crawl_task&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;result_dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;()}&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;concurrent&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;futures&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;as_completed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;future_tasks&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;result_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;我们映射了一个临时字典&lt;code&gt;future_tasks&lt;/code&gt;。里面包含了&lt;code&gt;submit&lt;/code&gt;方法进行的函数预订，参数是&lt;code&gt;result_dict&lt;/code&gt;的每个URL键。也就是说，我们用&lt;code&gt;future_tasks&lt;/code&gt;为每个键创建了一个入口（entry）。映射之后，我们需通过&lt;code&gt;concurrent.futures.as_completed(fs, timeout=None)&lt;/code&gt;方法来寻找&lt;code&gt;future_tasks&lt;/code&gt;里入口，通过一个循环来获取前面函数预订的结果。这个调用会返回一个由&lt;code&gt;Future&lt;/code&gt;对象实例组成的迭代器（iterator）。因此，我们可以迭代出每一个已经被处理好的预订结果。在&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;对象的最后，我们用&lt;code&gt;Future&lt;/code&gt;对象&lt;code&gt;result()&lt;/code&gt;方法获取抓取线程的结果。在这个例子的抓取阶段，&lt;code&gt;Future&lt;/code&gt;对象返回的结果是元组。用这种方式我们获得的&lt;code&gt;future_tasks&lt;/code&gt;最终结果如下图所示：
&lt;img src="http://muxuezi.github.io/posts/ppp/threading_webcrawler.png" alt=""&gt;
我们再一次看到线程池中的线程出现的顺序并不是自然顺序，这是由于线程具有不确定性。重要的是通过打印&lt;code&gt;result_dict&lt;/code&gt;的项目来展示最终结果。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://muxuezi.github.io/posts/ppp/ch4/parallel_web_crawler.py"&gt;源代码&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="本章小结"&gt;本章小结&lt;a class="anchor-link" href="http://muxuezi.github.io/posts/4using-the-threading-and-concurrentfutures-modules.html#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"&gt;¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;在这一章里，我们重点介绍了线程的概念。我们通过&lt;code&gt;threading&lt;/code&gt;和&lt;code&gt;concurrent.futures&lt;/code&gt;模块实现了上一章里提到的两个问题。通过问题的解决展示了两个模块的原理和灵活性。&lt;/p&gt;
&lt;p&gt;下一章，我们将重点介绍如何用&lt;code&gt;multiprocessing&lt;/code&gt;和&lt;code&gt;ProcessPoolExecutor&lt;/code&gt;解决这两个问题。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
</description><category>Parallel Programming with Python</category><category>Python</category><guid>http://muxuezi.github.io/posts/4using-the-threading-and-concurrentfutures-modules.html</guid><pubDate>Mon, 28 Sep 2015 12:42:03 GMT</pubDate></item></channel></rss>