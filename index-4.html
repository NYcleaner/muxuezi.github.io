<!DOCTYPE html>
<html prefix="
og: http://ogp.me/ns#
article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Github Blog of tj2">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>绿萝间 (old posts, page 4) | 绿萝间</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="canonical" href="http://muxuezi.github.io/index-4.html">
<link rel="prev" href="index-5.html" type="text/html">
<link rel="next" href="index-3.html" type="text/html">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
    },
    displayAlign: 'center', // Change this to 'center' to center equations.
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}}
    }
});
</script><!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://muxuezi.github.io/">

                <span id="blog-title">绿萝间</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>
                </li>
<li>
<a href="rss.xml">RSS feed</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
<div class="postindex">
    <article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/creating-sample-data-for-toy-analysis/" class="u-url">creating-sample-data-for-toy-analysis</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Tao Junjie</span></p>
            <p class="dateline"><a href="posts/creating-sample-data-for-toy-analysis/" rel="bookmark"><time class="published dt-published" datetime="2015-07-27T14:57:52+08:00" itemprop="datePublished" title="Publication date">2015-07-27 14:57</time></a></p>
                <p class="commentline">            <a href="posts/creating-sample-data-for-toy-analysis/#disqus_thread" data-disqus-identifier="cache/posts/creating-sample-data-for-toy-analysis.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div tabindex="-1" id="notebook" class="border-box-sizing">
    <div class="container" id="notebook-container">

<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="创建试验样本数据">创建试验样本数据<a class="anchor-link" href="posts/creating-sample-data-for-toy-analysis/#%E5%88%9B%E5%BB%BA%E8%AF%95%E9%AA%8C%E6%A0%B7%E6%9C%AC%E6%95%B0%E6%8D%AE">¶</a>
</h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>希望你在学习本书时用自己的数据来试验，如果实在没有数据，下面就介绍如何用scikit-learn创建一些试验用的样本数据（toy data）。</p>
<!-- TEASER_END -->
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Getting-ready">Getting ready<a class="anchor-link" href="posts/creating-sample-data-for-toy-analysis/#Getting-ready">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>与前面获取内置数据集，获取新数据集的过程类似，创建样本数据集，用<code>make_数据集名称</code>函数。这些数据集都是人造的：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">datasets</span>

<span class="n">datasets</span><span class="o">.</span><span class="n">make_</span><span class="o">*</span><span class="err">?</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">

<pre><code>datasets.make_biclusters
datasets.make_blobs
datasets.make_checkerboard
datasets.make_circles
datasets.make_classification
datasets.make_friedman1
datasets.make_friedman2
datasets.make_friedman3
datasets.make_gaussian_quantiles
datasets.make_hastie_10_2
datasets.make_low_rank_matrix
datasets.make_moons
datasets.make_multilabel_classification
datasets.make_regression
datasets.make_s_curve
datasets.make_sparse_coded_signal
datasets.make_sparse_spd_matrix
datasets.make_sparse_uncorrelated
datasets.make_spd_matrix
datasets.make_swiss_roll</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>为了简便，下面我们用<code>d</code>表示<code>datasets</code>，<code>np</code>表示<code>numpy</code>：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">import</span> <span class="nn">sklearn.datasets</span> <span class="k">as</span> <span class="nn">d</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="How-to-do-it...">How to do it...<a class="anchor-link" href="posts/creating-sample-data-for-toy-analysis/#How-to-do-it...">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>这一节将带你创建几个数据集；在后面的<em>How it works...</em>一节，我们会检验这些数据集的特性。除了样本数据集，后面还会创建一些具有特定属性的数据集来显示算法的特点。</p>
<p>首先，我们创建回归（regression）数据集：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [2]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">reg_data</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">make_regression</span><span class="p">()</span>
<span class="n">reg_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">reg_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[2]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>((100, 100), (100,))</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><code>reg_data</code>默认是一个元组，第一个元素是$100\times100$的矩阵——100个样本，每个样本10个特征（自变量），第二个元素是1个因变量，对应自变量的样本数量，也是100个样本。然而，默认情况下，只有10个特征与因变量的相关（参数<code>n_informative</code>默认值是10），其他90个特征都与。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>可以自定义更复杂的数据集。比如，创建一个$1000\times10$的矩阵，5个特征与因变量相关，误差系数0.2，两个因变量。代码如下所示：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [3]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">complex_reg_data</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">make_regression</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="n">complex_reg_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">complex_reg_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[3]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>((1000, 10), (1000, 2))</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>分类数据集也很容易创建。很容易创建一个基本均衡分类集，但是这种情况现实中几乎不可能发生——大多数用户不会改变消费习惯，大多数交易都不是虚假的，等等。因此，创建一个非均衡数据集更有意义：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [4]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">classification_set</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">make_classification</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">])</span>
<span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">classification_set</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[4]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>array([10, 90], dtype=int64)</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>聚类数据集也可以创建。有一些函数可以为不同聚类算法创建对应的数据集。例如，<code>blobs</code>函数可以轻松创建K-Means聚类数据集：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [5]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="o">%</span><span class="k">matplotlib</span> inline
<span class="kn">import</span> <span class="nn">sklearn.datasets</span> <span class="k">as</span> <span class="nn">d</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">blobs</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">make_blobs</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">"A blob with 3 centers"</span><span class="p">)</span>

<span class="n">colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s">'r'</span><span class="p">,</span> <span class="s">'g'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">blobs</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">blobs</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">blobs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.75</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[5]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>&lt;matplotlib.collections.PathCollection at 0x88e44e0&gt;</pre>
</div>

</div>

<div class="output_area">
<div class="prompt"></div>


<div class="output_png output_subarea ">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAekAAAEKCAYAAAA2Hq27AAAABHNCSVQICAgIfAhkiAAAAAlwSFlz%0AAAALEgAACxIB0t1+/AAAIABJREFUeJzsnXecXFX5/99PNpseUiEQCL1IkaZSBYKAYAFE6UgVUQRE%0AQAXBr8OIgoKCICIWUECK4k8QpKMGBQREIPROIJACpPdks8/vj+dcZnazu9nZndmZ3f28X695Ze/M%0AvfecO0n2c556zN0RQgghRO3Rp9oTEEIIIUTLSKSFEEKIGkUiLYQQQtQoEmkhhBCiRpFICyGEEDWK%0ARFoIIYSoUSTSQrQTM5tgZl9q5bN1zazRzFb6f8rMzjWz68o8t7XNbJ6ZWRvnNJrZ+uUcVwhRWSTS%0AoteTxHemmfVbyameXp2l7M0J3P0tdx/qqfFBWwuK9mBmh5rZi2Y2x8ymm9nvzWxo+WbcrjmUfTEj%0ARHdDIi16NWa2LrAL0Ajs11XDdsEYnV0IPATs6u7DgPWBvsAPOj2rLsTM6qo9ByE6i0Ra9HaOAv4D%0AXAMc3Y7zNzSzR5OFeauZjWjpJDMba2a3mdkMM3vFzI4v+tiBAWZ2k5nNNbP/mdmWrdwnb2aXpZ/r%0AzWyBmV2Yjgea2WIzG17kbq8zsx8SC4/Lkwv8sqJb7mVmL5vZLDO7vLWHdPfJ7v5uNg1iEbNBa+eb%0A2eZmdl963mlm9p30fh8zO8vMXjWz983sj9l3VjTno8zsTTN7z8zOTp/tA3wHOCQ9w5Pp/WFmdpWZ%0ATTGzt83svCzEYGbHmNlDZnaxmb0P5MxsQzN7wMxmp/vf1NozCFGLSKRFb+co4A/A9cDeZrZaG+da%0AOv9YYA2gAbislXNvAt5K5x0InG9muxfdZ3/gT8AI4AbgVjPr28J9JgDj088fA6YCu6bjHYEX3H12%0A0fnu7ucA/wZOSi7wrxd9/hngo8CWwMFmtnerD2v2cTObDcwFPg/8rJXzhgL3A3em590Q+Hv6+BTC%0AQ7Fr+mwW8Itmt9gZ2BjYA/iemW3i7ncD5wM3pWfYJp37e2ApsWDYBvgkULwA2g54DVgtXX8ecLe7%0ADwfWpPW/LyFqEom06LWY2ceBtYE/ufsTxC/3w9u4xIFr3f15d18I/B8hdE3c12Y2DtgJONPdl7r7%0AROC3hMBnPO7uf3H35cDFwABghxbGfATYyMxGEtbxVcCaZjYY2A14oK1HbOG9H7n7XHefDPwT2LrV%0Ah3V/MInbWsBFwJutnPpZYIq7X5Ked767P5Y++wrwXXef4u7LgDxwYLMEu7y7L3H3p4GJwFZF8//g%0AGcxsDPAp4DR3X+Tu7xELh0OL7jXF3X/h7o3uvpgQ9HXNbM00t4dbe14hahGJtOjNHA3c6+4z0/GN%0ArNzlPbno57eAemB0s3PGAjPdfUGzc9csOn47+yEle71NWJpNcPdFwOOEIO9KiPLDhPWZHbdGS3Hp%0AaUU/LwSGtHF9NocpwN2Ed6AlxgGvt/LZusAtyb0+C3ie8ECM6cCc1iG+76lF97sSWLXonMnNrvk2%0AIfSPmdmzZnZsK/cWoiZpyb0mRI/HzAYCBwN9zGxqers/MNzMtkxWXUus3eznZcD7wOCi96cAI81s%0AiLvPLzr37aJzxhXNpQ9hrU5pZcwHCFfwNsB/0/E+hGv3X61cU+4M8npaj0m/BRzSxmfHuvt/mn+Q%0AkvbaovkzTAaWAKPcvbE917j7dOCENN7OwP1m9oC7t7aoEKKmkCUteiufIyy6TQn36lbp53/T1C1d%0AjAFfNLNNzWwQ8H3g5qzsKSO5kh8GLjCz/ikp7Dgi9p3xETM7IMWhvwEsJlzbLfFAmtNzyWU8gYjD%0Avu7uM1q5ZjptJHoVPU/LH5gdntz2mNk6wA+JuHNL/A1Yw8xOTc871My2S59dScTj1073WtXM2ptF%0AP41wVRuAu08F7gUuTmP0MbMNzGzX1m5gZgeZ2VrpcDYh4q0JvBA1h0Ra9FaOAq5297fd/d30mg5c%0ADhxuLTclceBaInlpKtAP+HqzzzMOI1y9U4C/AN9z938UnXcrYX3OBI4APp/i0y3xHyJmnVnNLwCL%0AWNGKLh7/UiL2O9PMWkz4ou26782Ah81sPvBgGvPLLd4kvAV7AfsS38vLFJLdLgVuA+41s7npWbYr%0AvryV8QFuTn/OMLPH089HEd/788R3dzOwehvP81HgETObB/wV+Lq7T2pjTCFqCmtmBJR+A7OriYzR%0Ad939w+m9kcAfiRjSJODgZhmoQgghhFgJ5bCkf0fEx4o5C7jP3TcmSjHOKsM4QgghRK+i05Y0fJAA%0AcnuRJf0isJu7Tzez1YEJ7v6hTg8khBBC9CIqFZMek+J7EAksY9o6WQghhBArUvHEsZT5WvYNBYQQ%0AQoieTqXqpKeb2eruPs3M1gDebX6CmUm4hRBC9Drcvd2b7FRKpG8jOjf9OP15a0snlTLR7oaZnevu%0A51Z7HpVCz9e96cnP15OfDfR83Z1SDdROu7vN7EaiccMmZjY5td37EWm3HeAT6VgIIYQQJdBpS9rd%0AD2vloz07e28hhBCiN6OOY5VjQrUnUGEmVHsCFWZCtSdQYSZUewIVZEK1J1BhJlR7AhVmQrUnUEuU%0ApU66QwObeU+OSQshhBDNKVX7ZEkLIYQQNYpEWgghhKhRJNJCCCFEjSKRFkKILsQMM2O4GUOqPRdR%0A+0ikhRCiizBjEHAFsUf3I2Z8z0y/h0Xr6B+HEEJ0HV8HdgXeA2YAhwCfr+qMRE0jkRZCiK5jW2BB%0A+rkRaAC2qd50RK0jkRZCiK5jEjCw6Lgv8GZ1piK6AxJpIYToOn4KTAFGAKOAicAfqjojUdOo45gQ%0AQnQhZgwGtgCWAc+4s6zKUxJdSKnaJ5EWQlQUM+qANYCF7sys9nyEqCZqCyqEqBnMWA34M3AH8IAZ%0A3zRDi3Mh2olEWghRSfLAhsDM9DoGGF/F+QjRrZBICyEqyRbAnPRzI/E7Z8PqTae2Sd3IxpmxbgoT%0AiF6ORFoIUUleBYamn40Q6rerN53axYx64FIiNPBX4BozVqnurES1kUgLISpJjuisNRwYSQjQPVWd%0AUe1yGLAHhdDA1kSHMtGL6VvtCQghei7uvGXGvoSLeyHwqjvVKSmpfTYjyrKy72chES4QvRhZ0kKI%0AiuLOAncmuvOKBLpNXgLqi44HAS9UaS6iRlCdtBBCtJMUIz6A6Bj2sDuPlfHe/YmY9E6ENf0ycLz7%0AB4l3ogegZiZCCFEB0v7PfwLWSW81Aue4c1sZx+gDrAfUAW+oG1nPQyIthBAVwIz9gR8S20xCbJSx%0AxJ3dqjerypGazuwPfJJIZPuVO5OrO6vSSJ6P/sAMdxqrPR9QxzEhhCg7ZgwAVm329jJgQAXHXNOM%0Aq834lxm/MmP1So3VCscAPwB2IMT6ZjM+ZcbWtV7DnerNTwceAv4O/MGMEVWeVoeQJS2EEG1gxgFE%0AKVl/YCzwFjAfWAW4wZ0fVmDMzwO/S2POBd4H3gA+11UucDP+RVQALSEWI1sSXoQ5wKPASbXqjjdj%0AL+ASwgOwnFhg3ePOGVWdGLKkhRCibJixCdHadAEwLb2GE0J1NXBh0bnDU6ew/iWOUZ96mj9kxv1m%0AnAhcQMSlFxFZ3sOANYG10zX9U/OTSlIsJOsQerGAEL6dgX0rPH5n2IyY//J0PJeoO+92qE5aCCFa%0AZyMi03ppOp4CrAZ81p2G7CQzDgPOTOfOMeMEd15u5xhfBY4FZhPd2b4DTeKnywiRngE0mHEBIZBu%0AxrXAT91pNGMc8G1gLeA/wGXuLO7AM2f8HjidsKSHpnnMKvp8zdYuTO7wXdJrDeAV4Hp33u3EfEph%0AMk0XGYPppuVsEmkhhGid6YQF2YcQziHAe80EehNCWPum1xDgMmCfdo6xDzCPWAgsJay/AYSLezRh%0AUTcQu4ntC+xHuJ0NOBp43Yz7geuIrm6L0vtrAKd17LGB8BTMBPYmhHoUIdR1xGLk+ZYuShnqP0vz%0AHJPOnQ7sZ8YXumi70tuBPYGPE9/nTMIj0u2QSAshROs8DvwROJj4Zd8AfLPZOesTseriJLLBZgxo%0ApyU7mxDURel4EfA6EUddTvyevhD4JSHECwnh8zSfHSi0Xp1RdI9PljCHFUiNZ24BbjFjGLHw2DZ9%0A/GvgH61cugOx09kqhLhDLB4WEG1Pb+7IfErBnWVmnEy4vQcAL7ozv9LjVgKJtBBCtII7bsYPgf9H%0ANDB5xf2DEqyMgYQ7dQkhnHWEQLU3A/onwFUUrM63gUMJV/sw4Fl3pgCY8Q6RwJUJTt90/jKa5hhl%0Alv9yyoA7c8w4hlgILHVnQRunD6Ow4xnp5yx+3mWak0qunu2q8SqFRFoI0e0wYyRhrdUBD7oztVJj%0AJYvyg3imGfsRsd9BwF3A3YRregQhso3AVEK82xKz7P5PmnEgsCPh7r43dRl7tIXTf024vD9EWMsz%0ACTHvT1jfGxPWdR3w63JmX6fvYdZKTwxhXJ7OXZVwyy8mvosHs5PM2AbYjUjqurWL3ODdDpVgCSG6%0AFWaMAW6iULc8D/iiO691wdgfJUqj5hPW62giVrxbms8SQjCfTHMq2y/YVKt9A7BpGmNYGu9dwlJ9%0Ak4jFrka46e+sVq90M3YgMtQ3JBYeDwAXuvNi+nwPokSqjhDxKcBB7u1aBHRrStU+WdJCiO7G0YQg%0AZm7nUcSWjqd2wdjbEcKSxXlnE8lJXwLOAdYFngB+UAGB3IEQvWmEsH2MsOZnElbrWsBz7vyyrZuY%0AMYqI1a5NLHBeLCETvV248wiwuxnWyvdwBgXrGiKm/yliESKKkEgLIbobo6CQXU0h87grmAlNRGfV%0ANPZfCev1QPcPkrfKTb+isftRSFRbl3Avv8NKel+YsRmRtb0OEV+eD0w147vu3JZqrxvdW45lm7Ed%0AcD7x3I8CZ7Xlpm5joTKQpn+HUMHubd0ZNTMRQnQ3/kEYGP0JN+8g4P4uGvt2Yneq0USd8JpETe67%0AwEeAH1dw7CcIYRsLjCMEezkRA+8HrA4cnxqjDC6+0IzdzPg5cCvhDh9KWLIDCc/A9824kHDTP2nG%0Ayal3d/E91gKuJNzss4ndui7p4LPcmu4zgEIW+INtXtFLUUxaCNGtSOJxBNEEpC/hIr28qzZQMGMg%0AkbS2O1ELnCWt9SGSx7Yqt6s7WbiXEkljowhhnU10PlslvZYCrxLC9z/g2NTkZE9CTBuATdItswYt%0A/YhYdtZFLasLHwmc6c4dRXP4FPAjaGI5rwZs4/5Bs5f2Pk9f4ATgs4TL/Sfu/LeUe3RXFJMWQvRo%0AkgD+Ib3KhhlrAl8gLPN73HmylfEXAXeZsZiIo9YRwtaPyPLua8bWhJX/jDvzWhirHjgS2AJ4CbjG%0AncVpAdK3hazsA4DPUShv6ksI6+uEyA0j3N3z0msbYH0zDiHiv5kYz6IQGuhLiHWmA/Noap3vCAWR%0AJkS82Pvan8gwLzmDPDWDuSK9RBtIpIUQPZqUFb0L4dp9PKs5bnbOWGKv6BGEQB1mxsnu/LuNW/+L%0AaB6yfTpeTAjv74ha5kZgphlHufN20VhG1EbvSQjcJ4EdUovP84FhZjwFnObO9HTZhmluWS32ckJ4%0Ah6b3ZsAKLTcPJ+qtG4gFwzrEJh2D0/X9CWt8IlEG9TEKiVx1hOgX8wiRpZ1tzdkIfKdaGeS9Bbm7%0AhRA9lhSb/T1RV+yEoB3r3rTJhRknASfBB6I4FHjNnUNaue/qhAv504SwvU+I5hQiNpzdZxTwgDun%0AFF07FriHENbsF3C2DeUcwjodTVjhh6dr9ic6ny1O19SncY8G7gV+QywWlhLi+xCR3DU2HW9ICO+c%0ANMcTgKeJJLGG1Pf7esIiN8JCP8qduc2eu44Q6VFEk5Vu2Q+7msjdLYQQBfYFNqcgmsOJUqnDmp03%0AgBC/YYRg1kPL7TST8F9HlDHVE/FgJ6zUDQghzFhI2rmqiD4U2npm9CcWEFlr0PeBrcyoT67v24ls%0A6u0JC3Yp8BrwWIo7nwwcRyxGniMWJj8nWpbOJJLd1iGE+fTmixR3JqeFwEcIy/vR5Nan2XnLab0d%0AqKgAEmkhRE9mVZqK4SIKTVCKuZdIRFufQkvLdczY2Z2Hmp27BSHQIwnruYEQ/w8Roj2cQg3wUOBv%0A2YWpB/YZRAvQ9Uk7WwGTKHTncsI1Py99RlEC2OlEXfbrxO5XM9Pni4BfFE/SjJ8A1xJWOcBjwGHu%0AzG7pi0qNRLoqS160E7m7hRA9ltT56jeE4GUdwm5y5zwAy5sBuwIbcevVRzLxqA/jdcuJ+O4y4N/F%0Arup0z68Sru4lhAVeT4jrIsK63YCwjGcQpUanp88/C5xMWOrLgfWIxcAswtLdgNhBa1qa72nuTGjH%0AMxqxGFjevKd2cq1vn57lgeIkttQ97WNp/NtX0o9blAm5u4UQIuHOI2Z8H/gWIYB/I5K2Mk4Fjgf6%0AsMc5q7Hmow3cccVzKYl5JC1nLg8hBLqeQkOOPoQreTMKse+FFNzs1xN9tdej0Ft7YfpzOeFmfobC%0AZh1ntVOgB6Xn2TUdXw/8OCtHS0lyt7Rw3X7ADylsAnKIGYdnLu4k/PsQu15NBm5uyf0tKo9EWgjR%0Ao3HnZjP+DFhxLbXlbTjRznMmsJz6+QtY7x9bMOaZNZm+1RJCTK9p4ZZvUqiNHgAfWLJDCdFbRgj4%0ADOAQ4BNESdTMdM8s8WtxunZIer8PhX2ix7Tz8b5OJHK9m67/IrEZyK0rue7bRLexLO6+EVH7fVc6%0A/gaxeMlc/58049hybtgh2oc6jgkhejzueAvNTgZRvJ3jgHnzWeXtSYx85Z/AX4Aj3ZnYwu3+SnTH%0AWkaUME0iOo0NJgyfesKF3EChKxkULHNLrwFE6VPWgnNh0RhNsqrbYDsK21Zmz/KRdlw3iKZegiwO%0AnpWsHUcsMt4nFgBbUthLWnQhsqSFEDWBGX0IQWsEpnRB/e00Ioa8EZGRPYR+i6ZzyEFneM7nt3aR%0AO0tTXPrDhNA+785cM/4LXEyI8Rwi9jwzjTOaEMJ+hOi9TAjlKMKdvApRBw3wPFGi1R4mpflnAl+X%0A3lsZdxENUmanZ1hK9B6H0AWj6V7UWevRDzBje8JLMJdwhzev0xZlQIljQoiqY8YQIjt5a0IgJgBn%0AtOZeTYK+K+EWfsmdpzo0bt5WBb5PCO4bwP95zid15F5pXqsQ5V2ZQH+ZsEiHEhth9AcuJLZtXGJG%0An5S5vQFhAS8A/u7ecvlXC+OtQWRwZ5nhzwHHuzexylu6bgDwTUJkZwA/LP4Ozfgl8f3OIxYTM4D9%0As7ppM/amENvvQyw8DnLn/fbMuzdTqvZVVKTNbBIFd84yd9+u6DOJtBACADO+Q/TjzmKyqxIlRle3%0AcK4RPaQ/k95y4Hx3buyi6TafzwCgT3NhTP2pf0VsMWmENXqhO9eWefwhxCJjGTCxHHHjVAt+GpEZ%0APhm4wJ3JRZ/fSXgHsozwMYTQX9/ZsXs6tZbd7cB4d291KzMhhCBqj7PsYScEZ7NWzt2c6Jn9PoUk%0ArLPMuKW9Fmg5SNb82UTrTcy4CzgnucMHEm7krxJdyVYlOnQ9spJ7jiU2rXirtS0gU1/wo4nf3ze6%0A8zDwn/I8VZDKsX7QxikDWHGryX4tnSg6R1fEpGUtCyFWxsvAVhSSoOrTey2xCoUsaQhB70O4ZbtM%0ApIGDCdd2tlj4NPCWGcuArxG/+yYCp6RGIW1ixmHAWaQEMDO+ngS4+JwtiW5iWdOT3cw4aSU9xivB%0AzUTN93xCnBdDl8+hV1Dp7G4H7jezx83syxUeSwjRffkZUTo0kkimegRadQu/RCQ6rUL8DhsNvAIt%0Ad9KqIB8lFgiNxO+6hRQalswhxHtrILeyG5mxNvhZ9J/lDJ5WR9+FfYGfma1gnR5EJIfNpJBBfnSZ%0AnqcUfkUkyb1D1Id/yZ1XqzCPHk+lLemd3X2qma0K3GdmL7r7B6stMzu36NwJ7j6hwvMRQtQg7swx%0A43Ci61Yj8Gpr+0O7M8OMLxNx6TWJvZPP7Kr9pIuYTNPfoQOI/Js+FFzBc2hP6ZI1jGXItNUY9vZQ%0AFg6vo2FAPcvrl+L1J5rx8yo8W5uk+VyVXmXHjE2BccAk91Y9Kt0CMxtP1KB37Pquyu42sxww391/%0Amo6VOCaE6LakTO5riB7cTmQ4Xwt8h8K2kSPSz4sJd/ytwC/TRhWFe33uuD158Fu309CvgfljB4KD%0ANULD4JfBzuNcux8Yw1UPrcLkna6g4O7uA1Vxd1cMM75EdILLGqn8yJ0bqjur8lEz2d1mNgioc/d5%0AZjaYaGCfd/d7OzJRIYSoNVJm9zaEmDxFtAO9jNgEIxPiAUTsdhmx+cbl7lzR5D55G89zB/6W268c%0Ax9Ihfalb1siI15fx3mYv8NErF/KZU4YSotzAP8+9nAdyWxFu7z82j1t3Z9IWoPcSHohsH+yhwO6t%0AJdJ1N2pJpNej0DO2L3C9u19Q9LlEWgjRrUjlX9sSGdgvu/NaC+f0IUqiBhNifQyFHt4DgDnu7NPk%0AmrytAfyNuy9ajecPHsWQaY001i9i0fDpHLvb6gyfnMXhBxFW9K6e865MkusSzNgc+ANN8wuGAwe2%0A9F13R2qmBMvd3yCSJoQQotuTBPocoh/3csDMONudO4rPS/HaiemaTZrdpp5CBnvhmpxPtbx9je2v%0AuJQ3x49k3hrLWTBmJms9Useg998jBBoiOS1LrnunxPn3Jaz+AUQ52EozzqvAW0Qp3lCikcoqxPdV%0A0rP2JNRxTAgh2oEZWwA3EFnVjUT3sAHA9m10RhsF/AlYI721FDjRvfW6Zhvx+prMXn8voJ7tL3ua%0AT516JSFcSwjrvBHYzXO+pIS59wOuJDLSlxNNSI6uRevUjK2AS4na8mnAye68UN1ZlY+acXevdGCJ%0AtBCiG2HGLkS8udgVOwrYrS2r1IyRRGnWIGJP55IEx/L2GaKxiBFCfbLn/L8lzv0g4FwKCW0jgSfd%0AOcbyNpawXN+sFRd68loMAhZ2QQ/3LkUiLYQQFSAlNd1BwRIdSbhn96uEkCTx/D9iD+oXgeuAFz3n%0AC9q8sKV7GacCJ1AQ6f7QuJBz6+4j2rEuJ+q6j/ecv1mO+YuWKVX7tFWlEEK0A3emAScRWdqrAa8D%0AX6uQQA8iyrt2BoYBewJnUGidWioTiezwLA9pFba6diqx//QswjuwGnB+J6YtKoC2qhRCiHbiziNm%0AfBzo5067Y8IdYBOik9qMdLyY6G++GhGn/QDL265ED/GhwN3AhS3Eqx8gdhnL2pU+wl5nPkJkqmeN%0AUuYAG5f9SUSnkCUthBBtYEadGSebca8ZtwIfr7BAQ8Se64qO+1CISRfmlrfNgJ8TrvdViN7fb1je%0ALrK8Dc7Oc8fd+SWxHeYO7hzPkHdfotAwBMJi7xbdvSxvq1vePm55a5493+OQJS2EEG1zImGBziHE%0A8HIzjnDn2ZVdaHkbRbipNwKeAS7xnM9r5dxNgA2BKYR7+kFgN8JNbcD1nvPmCWrbEWVdi4nY9XIi%0A4erTRDOQ7xSf7M5SCuVcDxId0o5M173b/Pxykr6LjQjX+kue61hClOVtZ2JhYkCd5e33nvOLyzfT%0A2kKJY0II0QZm3ENYqVnm8xha6Bq2wnV560eUX21I1DcPAp4EjvacNzY790DgexRafV5DlCHtR/Qz%0Afw64q5Xr8oRgrUOI7VJis5J6z/kORc/Rh1hkLEpbUWb3GAsMAd6qVHa35W1rYlOOfoSH4GbgB6UK%0AteWtD/Aw8bwLie9qBHC453yli6ZaoGaamQghRA9hIVFqVSxg7cmw3oiwbt8rumYrYCzwdnZSShL7%0ALtG8YykhPEcBdwI7EHtnNwLrWN5+2UzY7krnbk2IXyORcT6AyNaOMYzRwC+BDwGeNu34DYDnfEo7%0AnqWzXJTmN5t4voOJ9p+PlnifwcSCIvtOG9NrtfJMs/aQSAshRNv8hEi6GpOOpwK3t+O6BsLiy8h+%0Abt74ZJX0WeaGbiQs4q8CexCCVEdklr8G3JMsym0IK/J0oknJNwhLuT7d77yiMc4DNk336gucasZz%0AXdH3O811LIXyr0xY12j1otaZT+w+tgaRld4/vV9zTVnKhURaCCHawJ2HzPgisAthVd/ezs0eXiH2%0Axd6ZEOy+hHX8brPz3iN6e48h9okeQgj53oS4rQ68SQj39pa3+4ALKFjYjYSAjwd2T9c/4TkvFq6t%0A4YOGKw2ENbsxtCzSlrd64MvAjoQoXuo5n97SuSvDc95oeXuWsOJnUlhEvNKBe7nl7SSie9rqxPd0%0AZk+u7VZMWgghykSyGr9AWMAzif2WdyXi0s8CN3vOG1q47kjgYsKd+y5RSnUwYSlme1RPBX4MPE/E%0Ad2cQMezBwCLP+W6tzsv4I7AJI19eyEZ3jqBhwBBmbPxtf+MTN7byHOcD+xOLkgHEIuKA1pLeVobl%0AbRwhrOOIRcX5nvM/deRe6X5ZLHqe53zpys6vJdRxTAghuoAkPEOBNzzni9J7XwG+TsSv+xEZ4Qd4%0Azt9r5R5GtPw8jRDcJUQseSAhjBsSru56Ijt8d+AT6ZoZRbdaDfhw88SyD8YxNmbMUzfw+SM3pX5h%0AHfWLFjBk6osYh3jO325ybt76A/9L88gEYgRwquf8gXZ/QSs+ax+i9nte9n31RpQ4JoQQFSQJ69nA%0AoYTreJbl7TjP+STgWCI5KrPuViPKqP7cyu0+TpRAebqmHxGjHkg0LXmGSD4bTbix9wGeTuf3J0R9%0ANDCxNYEGcOdlO2fnx4BhNPadRf+5CzBWJbbR/EGz0xsplH1lIm0Ump50iDS/5q5+sRIk0kIIURq7%0AAocRlmwjkax1PnA4rNAi1IvfS81HNk/XPkAIcPE5DYT7+jXCeh5LZJYvAOYSm2ScDJwJ/JBoQPIc%0AYYm3Tb+FgwjLPstMbyD2am464Zwvs7xdBxxNxHz7Ei1QH1/pGKLsSKSFED2e5Go9iNiNajZwhee8%0Ao9sfjqOpZTmXKLcCuBo4lYJVPAt4wPK2ExFP3iqdPwuYANxKZCwPJMS5jujPfSZRSnUdEROuA9ZP%0Ac9/Nc563vN0LDCxhw407iSzwZWn+fYF7Wjn3J0Sy2seIcrHf9WYXdTVRTFoIUTUsb6sT7tq3POdz%0AKzjOcUTs2/iMAAAgAElEQVSpUhYrXgIclFzUpd7r40TN8UwKlvTTnvMjkyv8c8SGGO8Dvyae71oi%0Avpy14XyLEMuvAJ8EDiREejFwuuf87jTW40TP7iWEsNaney4nssH/SQjo8qL59SFKlJYQov7lNMYs%0A4A0iqa0B+HUZkrc+RrLmPefvdPRevQnFpIUQ3QLL2zGEm7YRWGJ5O9Fz/mSFhjuCaBZS3DVsd+B3%0AHbjXQ8DvCXfwciLB62yIEiHglvQCwPJ2CCGuEOJYB6xKWKhDge8THcaGAK97zhcWjVVPweXsxHf1%0AGSLreglRWjUSuDCNNZxYQGxOiPpUYE3CWt8E+DxR8jWFFkqgLG99Cbf9toSgX+U5n9/CeX2IbPQ9%0A0newPP39PbayL0+UhjbYEEJ0OZa3jQnLdi5h7dUBl6Vf/pUgqw0uZnlLJ64Mz7l7zn8K7EVYwJ/1%0AnE9u45JMdOdRqBG2NP6z6X6TUlvLTSxvX7C8bZ+s8veBV4FJ6ZXVGc8ghHcGcGg6F8JN/uH0/kwi%0AMQ3Chb46kWy2lGhReqXlbUSzuZ6X7rEbsf/01am9aXN2JQT6fcJCb0TbXFYEWdJCiGqQ1ctmNcPz%0ACetyqOVtbkc3X2iDKwkByuK7M2k9HtsuUnOPFRp8pI0kjiIyu/9FxJ2PSOP2I+LPLwBfK27JaXn7%0AMlG+lXEN8CPgp+l4KCt2MetD/B4fb3l7C9iSWAxAodHJEGIhVF/03nwiaWx9otwKy9swImb/HoVE%0Atk0Id/sTzR5zVLPjBcAYy5tV4O+uVyORFkJUg0mEwNSnP4cTsc2HgAWWt+97zu8o12Ce81ssb7OI%0AEqY5wHUd7aDVFpa3VYAbiazs5cQGGRcTSWufIyzYv3vOJza7bgRwCiGmg4C1gRzRWexookxqJ0Lg%0A6wmRfI2CWF5CfI9TKMS2IRYjRny/fdP7meeijqa11i15MbyV95+n0EjFiYXAoxLo8iORFkJ0OZ7z%0A11JXq58R4lxHxF7fJETlAsvbZM/502UccwKRUV1JdiGStrLmJfVED+6rPedXtnHdMMLC7U9Yr058%0AJ18lvo8PE1b4YiIWPYgQ2FUIYV6WxlqbcD+PTve4A7iJcHuvS7T5zHqF/7ZZ4txsIhFtD8I93p9Y%0ATK2wu5Tn/AXL221EyMIIS/qmlXw3TbC8HUqUk/Undgu7pKVubL0dibQQolrMIARlErAZYbGtC7xE%0ACMmWROOO7kTz36mNhNiujCmEsG9KfA9ZHHgUIWT9CMs8q6leRgjjHEKwB6Tzs/KwOqJ16CWpicgD%0A8EEuwAbAlObWfOqL/W0iFp0ljv28pe0rLW9rAfsSW282EBb+9y1vE9rTptPyNp7Y+WsusfA4hnDB%0A/3Jl1/Y2JNJCiGqxDiE4iwjR6UcIDun9Wa1cV3MU7cn8BBETzra2HAxcuzI3sOd8aYpJ/5lI8IIQ%0AYUv3yPajzizsBmIBsxURy886kC0nunrVEXHxvxGLnmycl4GX25jHYuCydjzymhT2rs7mOjI999R2%0AXL8bKas/Hc8nEvEk0s1QdrcQolq8SaFu+A1CWJYTv+j/S+w3XNNY3szy9i1iQ4w/EiVd3ybc6q8R%0A7vyftnqDIpLreR9icbKUMKL6EKL7FyK+XEeI/9OEoC9J5xZnjPclFj1OLIQqwds0tfizhcSMVq9o%0ASrb9ZkaT/a9FAVnSQohq8XciFnkgIdaPEiL3FvCQ57z5vsu1yM6ExZo1NlmVyNo+vCM385y/b3n7%0AHVGrvJBwBw8E7gfOIZLHnNhiMmtYktVeOxGXXp8Q8kWEmGZbT+5GhBEmNtvGsiPzfMfy9j2ixnsQ%0AsVA4pYQdqW4iEunGpuOFRIKdaIY6jgkhqkaq712DsMTe7HbbDubtCKKRSbZxRB0wyHP+0U7ccyhw%0AObANYR3fApzbfAMNy9sAoqf2CEKsB1LopgbhqdiRcL//iugOBmFtn+I5/3dH51g0hxHEwmRKS01P%0AVnLtMKKhTD3wcG/pWKatKoUQvZKilpzZXs6/br4NYxnG6EPEY42wUndixRahz3XUkm42zqrAMs/5%0AzDbOm0gscgak13IiCW0akTH+XcJK/SkFd/JgYL7n/BPpHn2JLO1D0/VXEtnoKqeqAGoLKoTorWT9%0AuZcQFuXulrfPt7aXc6mkfZZ/Rri4IZLETiL6ch9FuJ3fA160vD1MQfBuKFXwktXcnjruFykk2X2E%0AsOTnUUjo6kOIdTGLCOs741iiFntmOv90QujvKmXOojIocUwI0VM4jqj1nUOI5QhgfBnvfzTRDnMB%0AIcg7ASd6zi8C9gYOAW5IfzphBOWBE5K1WgnOJp53OCHOC9PcRhOLleeAicSCYRDxO38UUOzq/kTR%0AdUvTn7tWaL6iRCTSQohuT3J1jyZqgNcnXL/lDqdtQQjdVsCHiJrkr1refkQ0G3mFiLEuJER6IyIx%0A6jzgqhRDLispAeyzxAJld2LDkrcI0R4A3EwsJr5BiPYIIvP8u0W3eY9CljaENf4u7cDytqfl7Z+W%0At/9a3s63vA3s1AOJFZC7WwjRE/gSUac8jBDI0YQV+UAZx3ibiEdnmdR1RInTZ9PrAqIEqT8RTx5A%0AxKnnEfs4fxH4bRnnA4DnfB7RVATg5ZTM9j7hVfgg3uw537WV3to/S/MbnY6nEvtYt4nlbQsiI3tR%0Aeu1PWOHf69wTiWIk0kKInsDRRDbzLMJa7Adc4zlvl0XYTp4lvI9OWOlZX+vMVXximseOhBWddQnL%0Asp43KL6Z5e1gwvIdANwG/LCz2e2p1GodCvHshjTP9YDnW4qNe85ft7wdAOyQ5vuvdu7t/RFCQ7Jd%0AvmYRSXsS6TIikRZC9AQy8XkvvVaj/Y012stswmWciXP/orEbgb6pJ/m/CHe4EU1FNiCs06eyG1ne%0AdibEbC5haR+Y/vxJZyboOV9meXuHyDKfS1j7fQgXeFvXTQf+WuJw8yh87xDfR9k3LentKCYthOgJ%0A/JZwdQ8nXM2ziM0iysnzRF0yFMRpCSGEI4jdryCyv5+jsANV33Ttn4vutWPR9X0JgTvC8jaaznMa%0A0cxkeHr9wnP+TBnu25y7iC03V02vvkT8XZQRWdJCiJ7AdYQw70WI41WlbkWZXMXHEBt7vErsErUg%0A+9xzPtvydiQRw12DKFN6i2jGcR+x/zOEhTmC6JmdbSt5jed8edFw7xNG0iBiU416QrD/n+XtEM/5%0AtFLmXozn/FnL297EZiUzi/esLiee80WWty8CexK11493tpOZWBE1MxFC9HpSdvglhMgvISzbp4Bj%0AWmpPannr11r8OO3wdCkhvE4I/uHFgp/2nb6esLoHEm7xF4jkt995zjvl9ha1S6naJ3e3EEKEu3YP%0AIp49hyhB2oLY23kF2krwSvtWHw5cBJxLM4FO58wlOnw9TWSNP0MkYC0nXNRCAHJ3CyEEFLK1i12L%0AWRZ3yXjOnyPi0m2ds8DydjVwZhpnIGE43deRMdtL6pm9HfF8j6YSLlGjSKSFECIs54eITluLiLKo%0Al4i2m5XkD0Rc+jDC5f1jz3k5a7ubYHkbQyS4jUpvTbe8He451zaRNYrc3UKIXk+qHz4N+A1RD30j%0AcFwXbJfZh3BvDyOSzUan+HilOJlw7c9Mr7HACRUcT3QSWdJCCAF4zhcTmdtdybHAkURNdx/gVOAd%0A4M4KjZftQZ2xlMKezqIGkSUthBDVI9vcYjnh7q705hYPUYh91xFZ7A9WcDzRSWRJCyG6PZa39Qgr%0AcVKl6oIrxHRgcwqtQ/vSzs0tOsi1xPd0GJE49jvgTxUcT3QS1UkLIbo1lrdjiXhy1izkW57z+6s4%0ApXZjeVuXSB7L9nyeChzmOS93S9Pm49YBnvatFl1IqdonkRZCdFuSyN1G1DY3EFnZ9cDHU4y55kmt%0AQHckFhkPtnNzC9FNKVX75O4WQnRnxhDi1pCOFxMlTSOJtp01Typ/ur3a8xC1ScUSx8xsHzN70cxe%0AMbMzKzWOEKJXM4mIrQ5Mx6sQu1W9V60JCVFOKiLSZlYHXA7sA2wGHGZmm1ZiLCFE7yVtonEakak8%0AikjA+loX1DcL0SVUJCZtZjsCOXffJx2fBeDuPyo6RzFpIURZsLz1I5qBzPCcN6zsfCGqRa3EpNcE%0AJhcdvw1sX6GxhBC9nLThRUlbUwrRHaiUSLfLPDezc4sOJ7j7hIrMRgghhKgCZjYeGN/R6ysl0u8A%0A44qOxxHWdBPc/dwKjS+EEEJUnWR8TsiOzSxXyvWVyu5+HNjIzNY1s37AIUQtoxBCCCHaSUUsaXdv%0AMLOTgXuIrMur3P2FSowlhBBC9FTUcUwIIYToIkrVPu2CJYQQQtQoEmkhhBCiRpFICyGEEDWKRFoI%0AIYSoUSTSQgghRI0ikRZCCCFqFIm0EEIIUaNIpIUQQogaRSIthBBC1CgSaSGEEKJGkUgLIYQQNYpE%0AWgghhKhRJNJCCCFEjSKRFkIIIWoUibQQQghRo0ikhRBCiBpFIi2EEELUKBJpIYQQokaRSAshhBA1%0AikRaCCGEqFEk0kIIIUSNIpEWQgghahSJtBBCCFGjSKSFEEKIGkUiLYQQQtQoEmkhhBCiRpFICyGE%0AEDWKRFoIIYSoUSTSQgghRI0ikRZCCCFqFIm0EEIIUaNIpIUQQogaRSIthBBC1CgSaSGEEKJGkUgL%0AIYQQNYpEWgghhKhRJNJCCCFEjSKRFkIIIWoUibQQQghRo0ikhRBCiBpFIi2EEELUKBJpIYQQokaR%0ASAshhBA1ikRaCCGEqFEk0kIIIUSN0rfaExCirJitC2wDzAMewH1ZVecjhBCdQCIteg5m2wNXUvh3%0A/SRmx+O+tIqzEkKIDlMRd7eZnWtmb5vZk+m1TyXGEaIZ5wINwPvptS2wVzUnJIQQnaFSMWkHLnb3%0AbdLr7gqNI7oSs20w+ytmD2N2IWZDqj2lZowCFhcdGzC8SnMRQohOU8nEMavgvUVXY7YW8BtgLaAR%0A+AxwQVXntCL/BkYS/64HAMuBiVWdkRBCdIJKivQpZjbRzK4yM1kz3Z+tgXpgLrAMeA/YHbNaqhA4%0AF7gfGEEsJL6F+7Ml3cGsDrMtMNsKswHln6IQQrQfc/eOXWh2H7B6Cx+dAzxC/BIHOA9Yw92/1Ox6%0AB/JFb01w9wkdmoyoPGbjgcuAGemd/kSC1vZ09B9RpTCzDs0pRPmXRCzbgcnAsbi/X94JCiF6Cxa/%0AO8cXvZVz93Z7mjss0u0eIEpibnf3Dzd730uZqOgEZgbsBxwALASuxP3pEu9RD1xNlDf1IVzJ38X9%0Ar+Wd7ArjrgFsAswCni77gsBsU+AEYAiwgEg0ezd9Ohq4HfezyzqmEKLXUqr2VaQEy8zWcPep6fAA%0A4JlKjCPazYFAjkiqqgd2wOxQ3F9u9x3cl2F2PLAP4U6eiPuTlZjsBxRKqgYSOQ5/wux7ZRNqsw2A%0A64B+hAt/bUKoMxYBG5VlLCGE6ACVqpP+sZltTbgM3wC+UqFxRPv4ImFBZwI0BtgbaL9IA7gvASpr%0AOTfl58AGhEAb8e/oDiKcAmbDgPWAGbhP7sD99wYGAdPT8RxgNWAS8W93EPBUGmsDYCwwqYNjCSFE%0AyVREpN39qErcV3SYBlbMtm+sxkTajVkd4eY2Yv4AQ4E9gEcw2wr4FREbr8Ps17hfXuIozS3ymcT3%0AMiodPwZcitmxwGmEi98wOwf3O0p9JCGEKJVayswVlePXhMt4JLAq0TLz9qrOqDlmIzC7BLMHMLsO%0AWJemi4vMml6WYuw/IxaZs9PrBMy2LHHUO4D5xHcygrCcTwd2J2LTx6f3v0FY2bMJj8QPMBvcwScV%0AQoh2U/HEsVYHVuJY12K2M7Av4fK+DvdJ1Z1QESG61xFlXnOAwYR4TiFc0nXpzPeAw4EngCcpuKkh%0A6rdfIFz4v2936VW4sY9JY96O+z+bfb4t8Ns0r4wRwL5yewshSqUmEsdEDeL+EPBQtafRCiOArSiU%0A7S0lOoX9nkh02zC9/wvc/wOA2ZvAGkTW92hgHGF5rwt8ArMjcH9hpSO7vwb8XxtnvEm4wAcRVvQq%0AhCdiehvXCCFEWZC7W9QCi4n4cF3Re3WEJf0FwvW8M+5XFn3+dUKgRxBW9BRgGlHH3Z+oKmgbsyGY%0A7YbZLpgNavEc9xnAKWl+owmB/qo27RBCdAVyd4vSiLriXYnypDuSiJXjvicCJxELRwceAE7GvfUE%0AN7N+hDV9EbADEXOHcOn/inBhfwx4B8jj/mLRtasB1xPZ3ABvAUfhPquVsfoCw4BZbc5JCCHaoFTt%0Ak0iL9hN1y78i6oohLNeDCYv2GKKrzrvAZbi/WeK9DdgF2Iywiu/EvaHtiz649lzgLKLW2QgrfDaF%0A9qBLgKkUdsRaTLQQPYoI+SxOz3Al7j8pad7diWjhugawCPeZ1Z6OEL0RxaRFJTmDKEPK4rGrA/sT%0AFuwxRMx2K2B7zD5XUjvNWC3+K71aJkTmC8COhHV8dbJ8VyFaeA4kRLkvUQu+gIgl9yes6ifS3AcT%0AjUv6EMLeLz3L+u2eb3fDbDTRGGYjoA9mfwAurLmWrkKIJkikRSkMIUQtw9N7hxOx4OVEVvZoYCfg%0AthTrHULs7zwQOBH4EPA88Cvcizt8rYzTgGOJBLG+RILYwYSVvAR4O523FSHWA4vmWUdY1v0Ika5L%0A79cXndOTs7W/R9Sdv08sTo4kMuTvreakhBBtI5HuLZjtBGxH/JK+k4itlmpF3Q6cTAhaX0KUHyDc%0Axlk/74zlmB1GuKGNyJJeAmxKxLN3BLbE7LgmMd6wlj9DWHyvEHHvxtTc5Gii4Ug2zrj0TFcRTU7G%0AEltULiXc16MokM15ECHQRtacJIR6JlCP2ZfTmFNK/G5qnQ8TO5hBLGCMEG2JtBA1jES6NxDW5vcI%0AMVojvfsCZt/E/d8l3OnXhBgfQLiSL8H9KcyuJBp+LCP+TU0lRPLHhGWd9cAeQ9ZmM7KktyXczpPS%0APA34AeFCd0JIdsLs7PTzYMIqbyBi3w70wX0mZgcS+1t/lhDctdK4/dKfAygIc2ZFOwXPwFLg0PTZ%0A6ZhdAtyG+7QSvp9a5lVge8LjkcXDSssbEEJ0OUoc66mYrU100noDuJsQo40puIAnEwlT+3W6KUeI%0A675E1vd0or75YuAgCmVVCwih/E/RlaPS+JPSfcYRXcBmUhDpkYRlvRlwLZFh7YTYPgV8Bvc5RdfO%0ATp/1JzK3n07PPY5YQFj6DEKwFhCZ3cPSz5sTCwEnLP9LgFy3z+iO7+dqIhRRB/wd+Cbuy9u8TghR%0AVpQ4Jkgu25MJt2YD0RhkGiHQywiLOmu5uQmdjcXGSu+29AKzfYGPU/j3ZYSbGcKSX0gI5cPAYMx+%0AT2yU8T4FK5f0ZxZb/johpkPT89QBN+GedQIbmZ4pE50lhBV/erpuf+ByYmGQZY2/RSS8nZXmtyaF%0AHbcyC/srwP+AWzvwzdQO7pMx25/waCwCXu32Cw8hegES6Z6G2cZE843MohxGWNSZsEEI3zxC8MpT%0A59yUrQghbqRQ92zAa0Q8vB/RwnME0QWtP2HVT0tzhWjDOZRwhb9BWOENhCt9KuE6X1g05iRCmIem%0AZxtOuNynpJj2X4l66pmEAE8lhHkEsbjIEQKdNfjJyrn6AB+lu4s0gPtCYGK1pyGEaD/qONbzGEuI%0AcxZ7XZeCwGVMIVy6t1CIEZeTt4h/W0sJq20p0fJzKdFX+2Rij/HDKdQp1xOCOTV91o9YQNxMiPyf%0AiVKrQYQALwYK8fSwqL9KJEeNIQT/hKLOYHWEiL8MvJ7mlVnpNwPnE99LY5pntsBYRM/O+hZC1DAS%0A6a7GzDD7ImYPYvYIZqemjOZyMYmwAPsRYjaAEJoXiTrhV4Dz0vFHgHMxG9LpUeO5PorZZ9M4jxHu%0A6ywLfC5wFyHAEAljxXGZBkKAsz3IBxBW9ZnApUTS2sVEffTTwJdwf6XJHNwnElne2+D+qSafuy8j%0A4rCrEpb7CELon8Ldcb8+fR/nUaidng08SnQmE0KILkeJY12N2d7ATwnRaiTE4iLcf1/GMfYD8oRI%0ArwY8S7iG+xIZ0rOJBKIFhHX6H+DLHW5sEYljZwOHUHBtn0ssGDYlFoNvAg9+EAc12wW4grBkV6dg%0AUd8E7Ey4qrP48ijC6p5MeAqmtdq+s+15DiZEfydi4TKJsNb/gvvTReetQrjsG4AncF9S9NkGhKX+%0ABu5TS56DEKJXo7agtY7Zj4BPEbFRCLfzy7gfUeZxhhBJQlcQwrw4/fkPIqlrdtHZo4FdOyR8Mdam%0AwJ+IZ2okrNBBwA5NBK7pNQZ8k6ixztzxPwH+BtxH01j58PQcX6EQV/8O7nd3cL5bEJni/YhFRQNw%0AHOEK/wJhbT+2Qnma2VeBr1EIHZyxwtaWQgjRBsrurn1m0HS3p/5UInnLfT7wJGZfJGqYRxPu3qeI%0AUqmMbC6d2dVpBOEizrKFlxIJXEOJOHBL83PgotSecgjwFu5Lkuv/WWBLInlsSPrzxHTfecR3dj5m%0Aj5fUerTAEUQMPNsacyTwZcKi/1B6jmMxuyC5wcFsI0Kgs4S8gcCFmO2UXOltY1ZPlJKtRXRb+6da%0AcgohVoZEuuu5Bvg0hSzmBUTMtTLEfsmnfHAcuzk9SewOlXWeuqbE9pzNeSXdawhR9rQqBaH7F+6P%0AtjG/qc2OGzE7iXCX702I/4PEd7YonbWEEMk1MVsOnANsQWSP/6Adbuh+FBYUpJ/HEUl204vOOR2z%0AG5KYjqGQkEeayygie77thUIsPC4FdsueEvgNlfx7F0L0COTurgZmI4DdCSv2wS6PbZoNINy644iS%0AnLs7bdWZfZRwV69OWNZzCMvXgTNxv7OEe/UhdtvaiUIS1ygioWwRYUkPAPYBfk40OplPuPPfAQ7A%0AfXEb99+BSERrSPPrRySHZT3IIeLoI4Gt0sJhLNEsZXF6DSOs6j1XWm9s9mHgDxRCHFkf8R1xn49Z%0Af8KS/1h6xss76CEQQtQ4ikmL0olFw9eIhiL/A64qKl0q9V6HAd8l2nZCxKbn4b5nWhwcRySTPUeU%0AY60opmYbAn8hkt3GEqLWh7Bys3aeZ6d7/I2C+EHEr4/C/RnaIhLXjk33vTbd668UsuFXAf6G+5lF%0A1+xBtDrtR1jPJ+L+Uju+k+2IRUfzPIDdcX8fs4sJr0G2AHkLOBD3RSvcSwjRrVFMWpRGCOe1hEAv%0AITa+2IBI6uoIzf9NNQADknX8C2CHNM4ngG0x+2oLlmgdETPejEIzlHqiN/c9wHTcZ2O2avq8DwXX%0AfVYP3TaRFNY8MewYovvY6kSDk0uaXfP3tFHJMGBmCS01XyQ8CyMJi38Y4cGYkTLJP0nEx52Iua9F%0AxORbDxMIIXoFqpMWWxI1y+8RZWHvAfsk8egIDxEiOZyIGw8nrOJ1CXfuu4RgvUsI9tot3ON1worO%0AYsdGiNteuL+UBHoAhWYno4k4+KrABGIzidKI/ZZHEAuBT+F+QYtWvvtS3N8rqee1+1yi/ej/iBDA%0APcDJKcSQubKar6zVslMIIUtaUN54h/vrmB1HWOLDgesIV+86LYyV1VRncehIHHNfhtkthFt8ABED%0AfgdwzIYRse+dCMH7MVH7vCmROHZbyT2pI57+S+L/Qx1wA2Y/Lmv2dWwiclwL78/D7FZiZ7GlhMfg%0AJaJhixCil6OYdG8nLNIbiZrqpURM9HbczyrjGH2IpiqXEPsaLyas7P8RceFTib2iIRK4LiVizTtT%0AEPLl6dydCffwu4SgDQOOxf3xDs7NCOt7EGGtZwljx+D+vw7ds/Q59AUOIzqeTQKuTta3EKKHoZi0%0AKA33xSkWewKFxLFrO3w/s10Jq3ARsWXlbMJK3YgQwBcJMXyOaFByEPAlClnVRxNx7FUJa3INwrpd%0AnK45nehGBpH5XUdsL9kxkY7/A6tSKL1qTK/VO3i/0nFvIDwO13XZmEKIboFEWmSbU1zU6ftEy9Of%0AUNjc45OEC3pjCn28NwGOB/5LJIZ9nhDbLMa7GNiGQgLY6xT2lc52ylqXiGtDCGrHm8GEa/3ldM9Z%0ARBwcovZbCCGqihLHRDk5nihdGkuI6jAiOSwrPWogxHczYm/nG4gWpRsSbnYIkXyDQkLYaoSlezfh%0ACs4Roj6CqJ1+hEjE6gynErtvjSJqrc/F/eVO3lMIITqNYtKifJg9QwjuUgq1za8T4jyLsIhHE9tO%0AHkQhrrxVuuYdwio+LH22d7rfG8CdRZtzjCGy0hcQPbaLt+Hs6Nz7pLnNbbMRihBCdAI1MxHVIRKw%0AXiXaZ2bJXn2I7Ou9CAu1jrB6pxFJYFnv7EGEWJ8NPIL7bIQQogeixDFRTWYQCWMjiFjxYiKh62dE%0ALHo+8AIRq85EvJEQ8Ds7vKuVEEL0UGRJi85jthmwJuG2PoYQ3jpi/+eDcJ/X7HwDvgUcSVjdzwIn%0AdXirzJXPbxeilnoo0X/7knbtXCWEEGVG7m7RtRT2WG4kLONb0s/vATe2Kbxmw4mEsfdKbkDS/vlt%0ATtReLyPi3sOJnuGdz2YXQogSkUiLrsNsHNF0ZA5RQlVPbFe5a8004zD7EnAGTbegXIr77tWblBCi%0At1Kq9qkES3SGUYTVnNU4Zy7kEdWZTos03ye7HxEbF0KImkciLTrDJMKFPCQdZ3ssd+3+2G1zJzHP%0AMUTNdT2RcS6EEDWP3N2ic5htQ/TaHkmI88nt2mO5K4kdvT5NZJH/B/fnqzwjIUQvRTFp0fVEtvYg%0AYGFZd44SQogehuqkRdcTwtw89iuEEKKTKCYthBBC1CgSaSGEEKJGkUgLIYQQNYpEWgghhKhRJNJC%0ACCFEjSKRFkIIIWoUibQQQghRo3RYpM3sIDN7zsyWm9m2zT77jpm9YmYvmtknOz9NIYQQovfRGUv6%0AGeAA4F/Fb1rsLXwIsBmwD3CFmfU6i93Mxld7DpVEz9e96cnP15OfDfR8vY0Oi6e7v+juL7fw0f7A%0Aje6+zN0nAa8C23V0nG7M+GpPoMKMr/YEKsz4ak+gwoyv9gQqyPhqT6DCjK/2BCrM+GpPoJaohIU7%0AFnUevZEAAAS1SURBVHi76PhtYM0KjCOEEEL0aNrs3W1m9wGrt/DR2e5+ewnjaNMFIYQQokQ6vQuW%0Amf0TOMPdn0jHZwG4+4/S8d1Azt0fbXadhFsIIUSvoxq7YBUPeBtwg5ldTLi5NwIea36BtqkUQggh%0A2qYzJVgHmNlkYAfgDjO7C8Ddnwf+BDwP3AV8zbXHsBBCCFEynXZ3CyGEEKIy1ET9spmdYWaNZjay%0A2nMpJ2Z2kZm9YGYTzewvZjas2nMqB2a2T2pU84qZnVnt+ZQTMxtnZv9MjXqeNbOvV3tO5cbM6szs%0ASTMrJfmzW2Bmw83sz+n/3fNmtkO151ROzOy09O/yGTO7wcz6V3tOncHMrjaz6Wb2TNF7I83sPjN7%0A2czuNbPh1ZxjZ2jl+UrShaqLtJmNA/YC3qz2XCrAvcDm7r4V8DLwnSrPp9OYWR1wOdGoZjPgMDPb%0AtLqzKivLgNPcfXMilHNSD3s+gFOJcFRPdKNdCtzp7psCWwIvVHk+ZcPM1gROAT7i7h8G6oBDqzur%0ATvM74ndJMWcB97n7xsDf03F3paXnK0kXqi7SwMXAt6s9iUrg7ve5e2M6fBRYq5rzKRPbAa+6+yR3%0AXwbcRDSw6RG4+zR3fyr9PJ/4JT+2urMqH2a2FvBp4Lc0Tfjs9iSLZBd3vxrA3RvcfU6Vp1Vu+gKD%0AzKwvMAh4p8rz6RTu/m9gVrO39wOuST9fA3yuSydVRlp6vlJ1oaoibWb7A2+7+9PVnEcXcRxwZ7Un%0AUQbWBCYXHffYZjVmti6wDfEfqadwCfAtoHFlJ3ZD1gPeM7PfmdkTZvYbMxtU7UmVC3d/B/gp8BYw%0ABZjt7vdXd1YVYYy7T08/TwfGVHMyFWalulBxkU6xhWdaeO1HmPm54tMrPZ9y08bz7Vt0zjnAUne/%0AoYpTLRc90UW6AmY2BPgzcGqyqLs9ZvZZ4F13f5Ju+H+tHfQFtgWucPdtgQV0b1dpE8xsBGFlrkt4%0Ad4aY2RFVnVSFSZVBPfJ3Tnt1oVx10q3i7nu19L6ZbUGsfCeaGYTJ/z8z287d3630vMpFa8+XYWbH%0AEO7FPbpkQpXnHWBc0fE4mraB7faYWT3w/4A/uPut1Z5PGdkJ2M/MPg0MAFYxs2vd/agqz6tcvE14%0A5v6bjv9MDxJpYE/gDXefAWBmfyH+Tq+v6qzKz3QzW93dp5nZGkC30YP2UoouVM3d7e7PuvsYd1/P%0A3dcj/oNt250EemWY2T6Ea3F/d19c7fmUiceBjcxsXTPrR+x4dluV51Q2LFaMVwHPu/vPqj2fcuLu%0AZ7v7uPT/7VDgHz1IoHH3acBkM9s4vbUn8FwVp1Ru3gR2MLOB6d/pnkQCYE/jNuDo9PPRQE9aKJes%0AC7WQOJbRE10aPweGAPelkpcrqj2hzuLuDcDJwD3EL4g/unuPyaAFdga+COye/s6eTP+peiI98f/c%0AKcD1ZjaRyO4+v8rzKRvu/hjhHXgCyPJ4fl29GXUeM7sReBjYxMwmm9n/b+cObQAEYCCKXlcjYRCY%0AhhmZBoNAYHBH8p6rrPqp6ZbkSLLOzJlkuedfetlvz8cueGYCAKWaLmkA4EGkAaCUSANAKZEGgFIi%0ADQClRBoASok0AJQSaQAodQHHW+I7IMnAvAAAAABJRU5ErkJggg==">
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="How-it-works...">How it works...<a class="anchor-link" href="posts/creating-sample-data-for-toy-analysis/#How-it-works...">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>下面让我们从源代码看看scikit-learn是如何生成回归数据集的。下面任何未重新定义的参数都使用<code>make_regression</code>函数的默认值。</p>
<p>其实非常简单。首先，函数调用时生成一个指定维度的随机数组。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [7]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">n_features</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>对于基本均衡数据集，其目标数据集生成方法是：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">ground_truth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeroes</span><span class="p">((</span><span class="n">np_samples</span><span class="p">,</span> <span class="n">n_target</span><span class="p">))</span>
<span class="n">ground_truth</span><span class="p">[:</span><span class="n">n_informative</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">100</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_informative</span><span class="p">,</span>
<span class="n">n_targets</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>然后<code>X</code>和<code>ground_truth</code>点积加上<code>bias</code>就得到了<code>y</code>：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ground_truth</span><span class="p">)</span> <span class="o">+</span> <span class="n">bias</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<blockquote>
<p>点积是一种基本的矩阵运算$A_{m \times n} \cdot B_{n \times s} = C_{m \times s}$。因此，<code>y</code>数据集里面样本数量是<code>n_samples</code>，即数据集的行数，因变量数量是<code>n_target</code>。</p>
</blockquote>
<p>由于Numpy的传播操作（broadcasting），<code>bias</code>虽然是标量，也会被增加到矩阵的每个元素上。增加噪声和数据混洗都很简单。这样试验用的回归数据集就完美了。</p>

</div>
</div>
</div>
    </div>
  </div>

    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/creating-binary-features-through-thresholding/" class="u-url">creating-binary-features-through-thresholding</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Tao Junjie</span></p>
            <p class="dateline"><a href="posts/creating-binary-features-through-thresholding/" rel="bookmark"><time class="published dt-published" datetime="2015-07-27T14:57:47+08:00" itemprop="datePublished" title="Publication date">2015-07-27 14:57</time></a></p>
                <p class="commentline">            <a href="posts/creating-binary-features-through-thresholding/#disqus_thread" data-disqus-identifier="cache/posts/creating-binary-features-through-thresholding.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div tabindex="-1" id="notebook" class="border-box-sizing">
    <div class="container" id="notebook-container">

<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="用阈值创建二元特征">用阈值创建二元特征<a class="anchor-link" href="posts/creating-binary-features-through-thresholding/#%E7%94%A8%E9%98%88%E5%80%BC%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%85%83%E7%89%B9%E5%BE%81">¶</a>
</h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>在前一个主题，我们介绍了数据转换成标准正态分布的方法。现在，我们看看另一种完全不同的转换方法。</p>
<p>当不需要呈标准化分布的数据时，我们可以不处理它们直接使用；但是，如果有足够理由，直接使用也许是聪明的做法。通常，尤其是处理连续数据时，可以通过建立二元特征来分割数据。</p>
<!-- TEASER_END -->
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Getting-ready">Getting ready<a class="anchor-link" href="posts/creating-binary-features-through-thresholding/#Getting-ready">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>通常建立二元特征是非常有用的方法，不过要格外小心。我们还是用<code>boston</code>数据集来学习如何创建二元特征。</p>
<p>首先，加载<code>boston</code>数据集：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">datasets</span>
<span class="n">boston</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">load_boston</span><span class="p">()</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="How-to-do-it...">How to do it...<a class="anchor-link" href="posts/creating-binary-features-through-thresholding/#How-to-do-it...">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>与标准化处理类似，scikit-learn有两种方法二元特征：</p>
<ul>
<li>
<code>preprocessing.binarize</code>（一个函数）</li>
<li>
<code>preprocessing.Binarizer</code>（一个类）</li>
</ul>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><code>boston</code>数据集的因变量是房子的价格中位数（单位：千美元）。这个数据集适合测试回归和其他连续型预测算法，但是假如现在我们想预测一座房子的价格是否高于总体均值。要解决这个问题，我们需要创建一个均值的阈值。如果一个值比均值大，则为<code>1</code>；否则，则为<code>0</code>：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [6]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">preprocessing</span>
<span class="n">new_target</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">binarize</span><span class="p">(</span><span class="n">boston</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">boston</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
<span class="n">new_target</span><span class="p">[</span><span class="mi">0</span><span class="p">,:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[6]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>array([ 1.,  0.,  1.,  1.,  1.])</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>很容易，让我们检查一下：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [22]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="p">(</span><span class="n">boston</span><span class="o">.</span><span class="n">target</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">boston</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[22]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>array([1, 0, 1, 1, 1])</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>既然Numpy已经很简单了，为什么还要用scikit-learn的函数呢？管道命令，将在<em>用管道命令联接多个预处理步骤</em>一节中介绍，会解释这个问题；要用管道命令就要用<code>Binarizer</code>类：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [24]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="nb">bin</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">Binarizer</span><span class="p">(</span><span class="n">boston</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
<span class="n">new_target</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">boston</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
<span class="n">new_target</span><span class="p">[</span><span class="mi">0</span><span class="p">,:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[24]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>array([ 1.,  0.,  1.,  1.,  1.])</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="How-it-works...">How it works...<a class="anchor-link" href="posts/creating-binary-features-through-thresholding/#How-it-works...">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>方法看着非常简单；其实scikit-learn在底层创建一个检测层，如果被监测的值比阈值大就返回<code>Ture</code>。然后把满足条件的值更新为<code>1</code>，不满足条件的更新为<code>0</code>。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="There's-more...">There's more...<a class="anchor-link" href="posts/creating-binary-features-through-thresholding/#There's-more...">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>让我们再介绍一些稀疏矩阵和<code>fit</code>方法的知识。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="稀疏矩阵">稀疏矩阵<a class="anchor-link" href="posts/creating-binary-features-through-thresholding/#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5">¶</a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>稀疏矩阵的<code>0</code>是不被存储的；这样可以节省很多空间。这就为<code>binarizer</code>造成了问题，需要指定阈值参数<code>threshold</code>不小于<code>0</code>来解决，如果<code>threshold</code>小于<code>0</code>就会出现错误：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [31]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">coo</span>
<span class="n">spar</span> <span class="o">=</span> <span class="n">coo</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">25</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="n">preprocessing</span><span class="o">.</span><span class="n">binarize</span><span class="p">(</span><span class="n">spar</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_text output_error">
<pre>
<span class="ansired">---------------------------------------------------------------------------</span>
<span class="ansired">ValueError</span>                                Traceback (most recent call last)
<span class="ansigreen">&lt;ipython-input-31-c9b5156c63ab&gt;</span> in <span class="ansicyan">&lt;module&gt;</span><span class="ansiblue">()</span>
<span class="ansigreen">      1</span> <span class="ansigreen">from</span> scipy<span class="ansiyellow">.</span>sparse <span class="ansigreen">import</span> coo<span class="ansiyellow"></span>
<span class="ansigreen">      2</span> spar <span class="ansiyellow">=</span> coo<span class="ansiyellow">.</span>coo_matrix<span class="ansiyellow">(</span>np<span class="ansiyellow">.</span>random<span class="ansiyellow">.</span>binomial<span class="ansiyellow">(</span><span class="ansicyan">1</span><span class="ansiyellow">,</span> <span class="ansicyan">.25</span><span class="ansiyellow">,</span> <span class="ansicyan">100</span><span class="ansiyellow">)</span><span class="ansiyellow">)</span><span class="ansiyellow"></span>
<span class="ansigreen">----&gt; 3</span><span class="ansiyellow"> </span>preprocessing<span class="ansiyellow">.</span>binarize<span class="ansiyellow">(</span>spar<span class="ansiyellow">,</span> threshold<span class="ansiyellow">=</span><span class="ansiyellow">-</span><span class="ansicyan">1</span><span class="ansiyellow">)</span><span class="ansiyellow"></span>

<span class="ansigreen">d:\programfiles\Miniconda3\lib\site-packages\sklearn\preprocessing\data.py</span> in <span class="ansicyan">binarize</span><span class="ansiblue">(X, threshold, copy)</span>
<span class="ansigreen">    718</span>     <span class="ansigreen">if</span> sparse<span class="ansiyellow">.</span>issparse<span class="ansiyellow">(</span>X<span class="ansiyellow">)</span><span class="ansiyellow">:</span><span class="ansiyellow"></span>
<span class="ansigreen">    719</span>         <span class="ansigreen">if</span> threshold <span class="ansiyellow">&lt;</span> <span class="ansicyan">0</span><span class="ansiyellow">:</span><span class="ansiyellow"></span>
<span class="ansigreen">--&gt; 720</span><span class="ansiyellow">             raise ValueError('Cannot binarize a sparse matrix with threshold '
</span><span class="ansigreen">    721</span>                              '&lt; 0')
<span class="ansigreen">    722</span>         cond <span class="ansiyellow">=</span> X<span class="ansiyellow">.</span>data <span class="ansiyellow">&gt;</span> threshold<span class="ansiyellow"></span>

<span class="ansired">ValueError</span>: Cannot binarize a sparse matrix with threshold &lt; 0</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="fit方法">
<code>fit</code>方法<a class="anchor-link" href="posts/creating-binary-features-through-thresholding/#fit%E6%96%B9%E6%B3%95">¶</a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><code>binarizer</code>类里面有<code>fit</code>方法，但是它只是通用接口，并没有实际的拟合操作，仅返回对象。</p>

</div>
</div>
</div>
    </div>
  </div>

    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/binarizing-label-features/" class="u-url">binarizing-label-features</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Tao Junjie</span></p>
            <p class="dateline"><a href="posts/binarizing-label-features/" rel="bookmark"><time class="published dt-published" datetime="2015-07-27T14:57:41+08:00" itemprop="datePublished" title="Publication date">2015-07-27 14:57</time></a></p>
                <p class="commentline">            <a href="posts/binarizing-label-features/#disqus_thread" data-disqus-identifier="cache/posts/binarizing-label-features.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div tabindex="-1" id="notebook" class="border-box-sizing">
    <div class="container" id="notebook-container">

<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="标签特征二元化">标签特征二元化<a class="anchor-link" href="posts/binarizing-label-features/#%E6%A0%87%E7%AD%BE%E7%89%B9%E5%BE%81%E4%BA%8C%E5%85%83%E5%8C%96">¶</a>
</h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>在这个主题中，我们将用另一种方式来演示分类变量。有些时候只有一两个分类特征是重要的，这时就要避免多余的维度，如果有多个分类变量就有可能会出现这些多余的维度。</p>
<!-- TEASER_END -->
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Getting-ready">Getting ready<a class="anchor-link" href="posts/binarizing-label-features/#Getting-ready">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>处理分类变量还有另一种方法，不需要通过<code>OneHotEncoder</code>，我们可以用<code>LabelBinarizer</code>。这是一个阈值与分类变量组合的方法。演示其用法之前，让我们加载<code>iris</code>数据集：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">datasets</span> <span class="k">as</span> <span class="n">d</span>
<span class="n">iris</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">load_iris</span><span class="p">()</span>
<span class="n">target</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="How-to-do-it...">How to do it...<a class="anchor-link" href="posts/binarizing-label-features/#How-to-do-it...">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>导入<code>LabelBinarizer()</code>创建一个对象：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [2]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="k">import</span> <span class="n">LabelBinarizer</span>
<span class="n">label_binarizer</span> <span class="o">=</span> <span class="n">LabelBinarizer</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>现在，将因变量的值转换成一个新的特征向量：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [3]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">new_target</span> <span class="o">=</span> <span class="n">label_binarizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>让我们看看<code>new_target</code>和<code>label_binarizer</code>对象的结果：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [4]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">new_target</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[4]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>(150, 3)</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [5]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">new_target</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[5]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>array([[1, 0, 0],
       [1, 0, 0],
       [1, 0, 0],
       [1, 0, 0],
       [1, 0, 0]])</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [6]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">new_target</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[6]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>array([[0, 0, 1],
       [0, 0, 1],
       [0, 0, 1],
       [0, 0, 1],
       [0, 0, 1]])</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [9]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">label_binarizer</span><span class="o">.</span><span class="n">classes_</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[9]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>array([0, 1, 2])</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="How-it-works...">How it works...<a class="anchor-link" href="posts/binarizing-label-features/#How-it-works...">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><code>iris</code>的因变量基数为<code>3</code>，就是说有三种值。当<code>LabelBinarizer</code>将$N \times 1$向量转换成$N \times C$矩阵时，$C$就是$N \times 1$向量的基数。需要注意的是，当<code>label_binarizer</code>处理因变量之后，再转换基数以外的值都是<code>[0,0,0]</code>：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [15]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">label_binarizer</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[15]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>array([[0, 0, 0]])</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="There's-more...">There's more...<a class="anchor-link" href="posts/binarizing-label-features/#There's-more...">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>0和1并不一定都是表示因变量中的阳性和阴性实例。例如，如果我们需要用<code>1000</code>表示阳性值，用<code>-1000</code>表示阴性值，我们可以用<code>label_binarizer</code>处理：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [22]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">label_binarizer</span> <span class="o">=</span> <span class="n">LabelBinarizer</span><span class="p">(</span><span class="n">neg_label</span><span class="o">=-</span><span class="mi">1000</span><span class="p">,</span> <span class="n">pos_label</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">label_binarizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">target</span><span class="p">)[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[22]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>array([[ 1000, -1000, -1000],
       [ 1000, -1000, -1000],
       [ 1000, -1000, -1000],
       [ 1000, -1000, -1000],
       [ 1000, -1000, -1000]])</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<blockquote>
<p>阳性和阴性值的唯一限制是，它们必须为整数。</p>
</blockquote>

</div>
</div>
</div>
    </div>
  </div>

    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/1-premodel-workflow/" class="u-url">1-premodel-workflow</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Tao Junjie</span></p>
            <p class="dateline"><a href="posts/1-premodel-workflow/" rel="bookmark"><time class="published dt-published" datetime="2015-07-27T13:36:10+08:00" itemprop="datePublished" title="Publication date">2015-07-27 13:36</time></a></p>
                <p class="commentline">            <a href="posts/1-premodel-workflow/#disqus_thread" data-disqus-identifier="cache/posts/1-premodel-workflow.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div tabindex="-1" id="notebook" class="border-box-sizing">
    <div class="container" id="notebook-container">

<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="建模前工作流">建模前工作流<a class="anchor-link" href="posts/1-premodel-workflow/#%E5%BB%BA%E6%A8%A1%E5%89%8D%E5%B7%A5%E4%BD%9C%E6%B5%81">¶</a>
</h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>本章包括以下主题：</p>
<ol>
<li><a href="posts/1-premodel-workflow/getting-sample-data-from-external-sources.html">从外部源获取样本数据</a></li>
<li><a href="posts/1-premodel-workflow/creating-sample-data-for-toy-analysis.html">创建试验样本数据</a></li>
<li><a href="posts/1-premodel-workflow/scaling-data-to-the-standard-normal.html">把数据调整为标准正态分布</a></li>
<li><a href="posts/1-premodel-workflow/creating-binary-features-through-thresholding.html">用阈值创建二元特征</a></li>
<li><a href="posts/1-premodel-workflow/working-with-categorical-variables.html">分类变量处理</a></li>
<li><a href="posts/1-premodel-workflow/binarizing-label-features.html">标签特征二元化</a></li>
<li><a href="posts/1-premodel-workflow/imputing-missing-values-through-various-strategies.html">处理缺失值</a></li>
<li><a href="posts/1-premodel-workflow/using-pipelines-for-multiple-preprocessing-steps.html">用管线命令处理多个步骤</a></li>
<li><a href="posts/1-premodel-workflow/reducing-dimensionality-with-pca.html">用主成分分析降维</a></li>
<li><a href="posts/1-premodel-workflow/using-factor-analytics-for-decomposition.html">用因子分析降维</a></li>
<li><a href="posts/1-premodel-workflow/kernel-pca-for-nonlinear-dimensionality-reduction.html">用核PCA实现非线性降维</a></li>
<li><a href="posts/1-premodel-workflow/using-truncated-svd-to-reduce-dimensionality.html">用截断奇异值分解降维</a></li>
<li><a href="posts/1-premodel-workflow/decomposition-to-classify-with-dictionarylearning.html">用字典学习分解法分类</a></li>
<li><a href="posts/1-premodel-workflow/putting-it-all-together-with-pipelines.html">用管线命令连接多个转换方法</a></li>
<li><a href="posts/1-premodel-workflow/using-gaussian-processes-for-regression.html">用正态随机过程处理回归</a></li>
<li><a href="posts/1-premodel-workflow/defining-the-gaussian-process-object-directly.html">直接定义一个正态随机过程对象</a></li>
<li><a href="posts/1-premodel-workflow/using-stochastic-gradient-descent-for-regression.html">用随机梯度下降处理回归</a></li>
</ol>
<!-- TEASER_END -->
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="简介">简介<a class="anchor-link" href="posts/1-premodel-workflow/#%E7%AE%80%E4%BB%8B">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>本章介绍数据获取（setting data），数据整理（preparing data）和建模前的降维（premodel dimensionality reduction）工作。这些内容并非机器学习（machine learning，ML）最核心的部分，但是它们往往决定模型的成败。</p>
<p>本章主要分三部分。首先，我们介绍如何创建模拟数据（fake data），这看着微不足道，但是创建模拟数据并用模型进行拟合是模型测试的重要步骤。更重要的是，当我们从零开始一行一行代码实现一个算法时，我们想知道算法功能是否达到预期，这时手上可能没有数据，我们可以创建模拟数据来测试。之后，我们将介绍一些数据预处理变换的方法，包括缺失数据填补（data imputation），分类变量编码（categorical variable encoding）。最后，我们介绍一些降维方法，如主成分分析，因子分析，以及正态随机过程等。</p>
<p>本章，尤其是前半部分与后面的章节衔接紧密。后面使用scikit-learn时，数据都源自本章内容。前两节介绍数据获取；紧接着介绍数据清洗。</p>
<blockquote>
<p>本书使用scikit-learn 0.15，NumPy 1.9和pandas 0.13，兼容Python2.7和Python3.4。还会用到其他的Python库，建议参考对应的官方安装指令。</p>
</blockquote>

</div>
</div>
</div>
    </div>
  </div>

    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/0-perface/" class="u-url">0-perface</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Tao Junjie</span></p>
            <p class="dateline"><a href="posts/0-perface/" rel="bookmark"><time class="published dt-published" datetime="2015-07-09T15:20:14+08:00" itemprop="datePublished" title="Publication date">2015-07-09 15:20</time></a></p>
                <p class="commentline">            <a href="posts/0-perface/#disqus_thread" data-disqus-identifier="cache/posts/0-perface.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div tabindex="-1" id="notebook" class="border-box-sizing">
    <div class="container" id="notebook-container">

<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="前言">前言<a class="anchor-link" href="posts/0-perface/#%E5%89%8D%E8%A8%80">¶</a>
</h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>这几年机器学习这种从经验学习的软件技术重现光明。在计算机诞生的早期，机器学习的概念已经出现，各种理论天马行空，限于计算成本而未能普及。随着计算设备的普及，日常生活中越来越多的机器学习应用，可以说它的成功开始变得习以为常。新应用如雨后春笋一般出现，很多都从机器学习中获得动力。</p>
<!-- TEASER_END-->
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>在这本书里，我们将看到一些机器学习的模型和算法。我们会介绍一些常用的机器学习任务和模型的效果评估方法。而这些模型和算法都是通过十分流行的Python机器学习库scikit-learn来完成，里面有许多机器学习的模型和算法，每个API都简单易用。</p>
<p>本书特点主要有：</p>
<ul>
<li>内容通俗易懂。本书只需要基本的编程和数学知识</li>
<li>案例实用。本书的案例都很容易上手，读者可以调整后解决自己的问题。</li>
</ul>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="本书内容简介">本书内容简介<a class="anchor-link" href="posts/0-perface/#%E6%9C%AC%E4%B9%A6%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><a href="http://muxuezi.github.io/posts/1-the-fundamentals-of-machine-learning.html"><em>第1章，机器学习基础</em></a>，将机器学习定义成一种通过学习经验改善工作效果的程序研究与设计过程。其他章节都以这个定义为基础，后面每一章里介绍的机器学习模型都是按照这个思路解决任务，评估效果。</p>
<p><a href="http://muxuezi.github.io/posts/2-linear-regression.html"><em>第2章，线性回归</em></a>，介绍线性回归模型，一种解释变量和模型参数与连续的响应变量相关的模型。本章介绍成本函数的定义，通过最小二乘法求解模型参数获得最优模型。</p>
<p><a href="http://muxuezi.github.io/posts/3-feature-extraction-and-preprocessing.html"><em>第3章，特征提取与处理</em></a>，介绍了常见的机器学习对象如文本，图像与分类变量的特征提取与处理方法。</p>
<p><a href="http://muxuezi.github.io/posts/4-from-linear-regression-to-logistic-regression.html"><em>第4章，从线性回归到逻辑回归</em></a>，介绍广义线性回归模型如何解决分类任务。将逻辑回归模型与特征提取技术结合起来实现一个垃圾短信分类器。</p>
<p><a href="http://muxuezi.github.io/posts/5-nonlinear-classification-and-regression-with-decision-trees.html"><em>第5章，决策树——非线性回归与分类</em></a>，介绍了一种回归和分类的非线性模型——决策树。用决策树集成方法实现了一个网页广告图片屏蔽器。</p>
<p><a href="http://muxuezi.github.io/posts/6-clustering-with-k-means.html"><em>第6章，K-Means聚类</em></a>，介绍非监督学习的K-Means聚类算法，并与逻辑回归组合起来实现一个照片分类器。</p>
<p><a href="http://muxuezi.github.io/posts/7-dimensionality-reduction-with-pca.html"><em>第7章，用PCA降维</em></a>，介绍另一种非监督学习任务——降维。我们用主成分分析实现高维数据的可视化，建立一个脸部识别器。</p>
<p><a href="http://muxuezi.github.io/posts/8-the-perceptron.html"><em>第8章，感知器</em></a>，介绍一种实时的，二元分类器——感知器。后面两章都是针对感知器的缺点发展起来的。</p>
<p><a href="http://muxuezi.github.io/posts/9-from-the-perceptron-to-support-vector-machines.html"><em>第9章，从感知器到支持向量机</em></a>，介绍支持向量机，是一种有效的非线性回归与分类模型。我们用支持向量机识别街景照片中的字母。</p>
<p><a href="http://muxuezi.github.io/posts/10-from-the-perceptron-to-artificial-neural-networks.html"><em>第10章，从感知器到人工神经网络</em></a>，介绍了人工神经网络，是一种强大的有效的非线性回归与分类模型。我们用人工神经网络识别手写数字。</p>

</div>
</div>
</div>
    </div>
  </div>

    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/10-from-the-perceptron-to-artificial-neural-networks/" class="u-url">10-from-the-perceptron-to-artificial-neural-networks</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Tao Junjie</span></p>
            <p class="dateline"><a href="posts/10-from-the-perceptron-to-artificial-neural-networks/" rel="bookmark"><time class="published dt-published" datetime="2015-07-09T15:19:44+08:00" itemprop="datePublished" title="Publication date">2015-07-09 15:19</time></a></p>
                <p class="commentline">            <a href="posts/10-from-the-perceptron-to-artificial-neural-networks/#disqus_thread" data-disqus-identifier="cache/posts/10-from-the-perceptron-to-artificial-neural-networks.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div tabindex="-1" id="notebook" class="border-box-sizing">
    <div class="container" id="notebook-container">

<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="从感知器到人工神经网络">从感知器到人工神经网络<a class="anchor-link" href="posts/10-from-the-perceptron-to-artificial-neural-networks/#%E4%BB%8E%E6%84%9F%E7%9F%A5%E5%99%A8%E5%88%B0%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">¶</a>
</h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>在<em>第8章，感知器</em>里，我们介绍了感知器，一种线性模型用来做二元分类。感知器不是一个通用函数近似器；它的决策边界必须是一个超平面。上一章里面介绍的支持向量机，用核函数修正了感知器的不足，将特征向量有效的映射到更高维的空间使得样本成为线性可分的数据集。本章，我们将介绍人工神经网络（artificial neural networks，ANN），一种用于强大的非线性回归和分类模型，用新的策略来克服感知器的缺点。</p>
<!-- TEASER_END-->
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>如果把感知器比喻成一个神经元，那么人工神经网络，即神经网，就是一个大脑。人脑就是由十几亿的神经元和上千亿的突触组成，人工神经网络是一种感知器或其他人工神经的有向图。这个图的边带有权重，这些权重是模型需要学习的参数。</p>
<p>有许多著作整本书描述人工神经网络；本章主要是对它的结构和训练方法进行介绍。目前scikit-learn的版本是0.16.1，在2014年Google Summer的项目中，多层感知器已经被作者实现，并提交在scikit-learn 0.15.1版本中，只是还没有被合并到scikit-learn。在未来的scikit-learn新版本中可能会原封不动的合并多层感知器的实现。也有一些神经网络模型的Python库，比如<a href="https://github.com/pybrain/pybrain">PyBrain</a>，<a href="https://github.com/lisa-lab/pylearn2">Pylearn2</a>和<a href="https://github.com/aigamedev/scikit-neuralnetwork">scikit-neuralnetwork</a>等。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="非线性决策边界">非线性决策边界<a class="anchor-link" href="posts/10-from-the-perceptron-to-artificial-neural-networks/#%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%86%B3%E7%AD%96%E8%BE%B9%E7%95%8C">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>在<em>第8章，感知器</em>里，我们介绍过布尔函数如AND（与），OR（或）和NAND（与非）可以用感知器近似，而XOR（异或）作为线性不可分函数不能被近似，如下图所示：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.1%20boolean.png" alt="boolean"></p>
<p>让我们深入研究XOR来感受一下人工神经网络的强大。AND是两个输入均为1结果才为1，OR是两个输入至少有1个1结果即为1。XOR与它们不同，XOR是当两个输入中有且仅有1个1结果才为1。我们把XOR输出为1的两个输入看出是两个条件均为真。第一个条件是至少有1个输入为1，这与OR的条件相同。第二个条件是两个输入不都为1，这与NAND的条件相同。我们可以通过处理OR和NAND的输入，生成同样输出的XOR，然后用AND验证两个函数的输出是否均为1。也就是说，OR，NAND和AND可以组合生成同样结果的XOR。</p>
<p>下面是XOR，OR，NAND和AND四种函数有两个输入A和B时的输出真值表。从这个表我们可以检验OR，NAND和AND组合函数的输出，与同样输入的XOR输出相同:</p>
<table>
<thead><tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">A AND B</th>
<th style="text-align:center">A NAND B</th>
<th style="text-align:center">A OR B</th>
<th style="text-align:center">A XOR B</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<table>
<thead><tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">A OR B</th>
<th style="text-align:center">A NAND B</th>
<th style="text-align:center">(A OR B) AND (A NAND B)</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>我们不使用单个感知器来表示XOR，而将建立一个具有多人工神经元的人工神经网络，每个神经元都近似一个线性函数。每个样本的特征表述都被输入到两个神经元：一个NAND神经元和一个OR神经元。这些神经元的输出将连接到第三个AND神经元上，测试XOR的条件是否为真。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="前馈与反馈人工神经网络">前馈与反馈人工神经网络<a class="anchor-link" href="posts/10-from-the-perceptron-to-artificial-neural-networks/#%E5%89%8D%E9%A6%88%E4%B8%8E%E5%8F%8D%E9%A6%88%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>人工神经网络由三个组成部分。第一个组成部分是架构（architecture），或称为拓扑结构（topology），描述神经元的层次与连接神经元的结构。第二个组成部分是神经网络使用的激励函数。第三个组成部分是找出最优权重值的学习算法。</p>
<p>人工神经网络主要分为两种类型。前馈人工神经网络（Feedforward neural networks）是最常用的神经网络类型，一般定义为有向无环图。信号只能沿着最终输入的那个方向传播。另一种类型是反馈人工神经网络（feedback neural networks），也称递归神经网络（recurrent neural networks），网络图中有环。反馈环表示网络的一种内部状态，随着不同时间内输入条件的改变，网络的行为也会发生变化。反馈人工神经网络的临时状态让它们适合处理涉及连续输入的问题。因为目前scikit-learn没有实现反馈人工神经网络，本文只介绍前馈人工神经网络。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="多层感知器">多层感知器<a class="anchor-link" href="posts/10-from-the-perceptron-to-artificial-neural-networks/#%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E5%99%A8">¶</a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>多层感知器（multilayer perceptron，MLP）是最流行的人工神经网络之一。它的名称不太恰当，多层感知器并非指单个带有多个层次的感知器，而是指可以是感知器的人工神经元组成的多个层次。MPL的层次结构是一个有向无环图。通常，每一层都全连接到下一层，某一层上的每个人工神经元的输出成为下一层若干人工神经元的输入。MLP至少有三层人工神经元。</p>
<p>输入层（input layer）由简单的输入人工神经元构成。每个输入神经元至少连接一个隐藏层（hidden layer）的人工神经元。隐藏层表示潜在的变量；层的输入和输出都不会出现在训练集中。隐藏层后面连接的是输出层（output layer）。下图所示的三层架构的多层感知器。带有<strong>+1</strong>标签的是常误差项神经元，大多数结构图中都不会画出来。</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.2%20mlp3layers.png" alt="mlp3layers"></p>
<p>隐藏层中的人工神经元，也称单元（units）通常用非线性激励函数，如双曲正切函数（hyperbolic tangent function）和逻辑函数（logistic function），公式如下所示：</p>
$$f(x) = tanh(x)$$$$f(x) = \frac 1 {1+e^{-x}}$$<p>和其他的监督模型一样，我们的目标是找到成本函数最小化的权重值。通常，MLP的成本函数是残差平方和的均值，计算公式如下所示，其中的$m$表示训练样本的数量：</p>
$$MSE = \frac 1 m \sum_{i=1}^m{(y_i-f(x_i))^2}$$
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="成本函数最小化">成本函数最小化<a class="anchor-link" href="posts/10-from-the-perceptron-to-artificial-neural-networks/#%E6%88%90%E6%9C%AC%E5%87%BD%E6%95%B0%E6%9C%80%E5%B0%8F%E5%8C%96">¶</a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>反向传播（backpropagation）算法经常用来连接优化算法求解成本函数最小化问题，比如梯度下降法。这个算法名称是反向（back）和传播（propagation）的合成词，是指误差在网络层的流向。理论上，反向传播可以用于训练具有任意层、任意数量隐藏单元的前馈人工神经网络，但是计算能力的实际限制会约束反向传播的能力。</p>
<p>反向传播与梯度下降法类似，根据成本函数的梯度变化不断更新模型参数。与我们前面介绍过的线性模型不同，神经网络包含不可见的隐藏单元；我们不能从训练集中找到它们。如果我们找不到这些隐藏单元，我们也就不能计算它们的误差，不能计算成本函数的梯度，进而无法求出权重值。如果一个随机变化是某个权重降低了成本函数值，那么我们保留这个变化，就可能同时改变另一个权重的值。这种做法有个明显的问题，就是其计算成本过高。而反向传播算法提供了一种有效的解决方法。</p>
<p>我们将用反向传播逐步来训练一个前馈人工神经网络。这个网络与两个输入单元，两个隐藏层分别有三个隐藏单元，两个输出单元。输入单元与第一个隐藏层的三个隐藏单元<code>Hidden1</code>，<code>Hidden2</code>和<code>Hidden3</code>全连接。单元之间连接的边开始用很小的随机数表示权重。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="前向传播">前向传播<a class="anchor-link" href="posts/10-from-the-perceptron-to-artificial-neural-networks/#%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD">¶</a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>在前向传播（forward propagation）阶段，特征变量被输入到网络，然后传播到下一层产生输出激励（activation）。首先，我们计算<code>Hidden1</code>单元的激励。我们找到<code>Hidden1</code>单元的的加权和，然后用激励函数处理输入的加权和。注意<code>Hidden1</code>单元会收到一个常误差项输入单元，并没有在下图中画出。其中$g(x)$是一个激励函数：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.3%20forwardpropagation1.png" alt="forwardpropagation1"></p>
<p>然后，我们计算第二个隐藏单元<code>Hidden2</code>。和<code>Hidden1</code>类似，它也会收到一个常误差项输入单元。我们计算输入单元的加权和，或成为预激励，经过激励函数处理的激励如下图所示：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.4%20forwardpropagation2.png" alt="forwardpropagation2"></p>
<p>同理，我们计算第三个隐藏单元<code>Hidden3</code>的激励：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.5%20forwardpropagation3.png" alt="forwardpropagation3"></p>
<p>第一个隐藏层三个隐藏单元的激励计算完之后，我们再处理第二个隐藏层。本例中，第一个隐藏层第一个隐藏层到第二个隐藏层。与第一个隐藏层三个隐藏单元计算过程类似，都有一个常误差项输入单元，并没有在图中画出，我们计算<code>Hidden4</code>的激励如下图所示：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.6%20forwardpropagation4.png" alt="forwardpropagation4"></p>
<p>按照同样方法计算<code>Hidden5</code>和<code>Hidden6</code>的激励。当第二个隐藏层三个隐藏单元的激励计算完成后，我们计算输出层。<code>Output1</code>的激励是第二个隐藏层三个隐藏单元的激励的加权和经过激励函数处理的结果。类似与隐藏单元，有一个常误差项的输入单元，如下图所示：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.7%20forwardpropagation5.png" alt="forwardpropagation5"></p>
<p>同理，我们计算第二个输出单元<code>Output2</code>的激励：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.8%20forwardpropagation6.png" alt="forwardpropagation6"></p>
<p>计算完神经网络中所有单元的激励之后，我们就完成了前向传播过程。用这些随机生成的权重值是不可能很好的近似网络的真实函数的。我们必须更新权重值来生成一个更好的近似函数。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="反向传播">反向传播<a class="anchor-link" href="posts/10-from-the-perceptron-to-artificial-neural-networks/#%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD">¶</a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>我们把输出单元计算的误差作为网络误差。隐藏单元表示不可见的变量；没有数据可以进行对照，因此我们无法度量隐藏单元。为了更新权重，我们必须把网络的误差反向传回。于是，我们先从<code>Output1</code>输出单元开始。其误差等于真实值与预测值的差，乘以激励函数对<code>Output1</code>输出单元的偏导数：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.9%20backpropagation1.png" alt="backpropagation1"></p>
<p>同理，我们计算第二个输出单元<code>Output2</code>的误差：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.10%20backpropagation2.png" alt="backpropagation2"></p>
<p>算完输出层的误差之后，我们把误差传回第二个隐藏层。首先，我们计算<code>Hidden4</code>的误差。把<code>Output1</code>的误差乘以连接<code>Hidden4</code>与<code>Output1</code>的权重，再<code>Output2</code>的误差乘以连接<code>Hidden4</code>与<code>Output2</code>的权重，再把它们相加就得到了<code>Hidden4</code>的误差：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.11%20backpropagation3.png" alt="backpropagation3"></p>
<p>同理，我们计算隐藏单元<code>Hidden5</code>的误差：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.12%20backpropagation4.png" alt="backpropagation4"></p>
<p>同理，我们计算隐藏单元<code>Hidden6</code>的误差：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.13%20backpropagation5.png" alt="backpropagation5"></p>
<p>算完第二个隐藏层的误差之后，同理把误差传回第一个隐藏层。<code>Hidden1</code>的误差就是激励函数对<code>Hidden1</code>隐藏单元的偏导数乘以第二隐藏层加权误差和，如下图所示：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.14%20backpropagation6.png" alt="backpropagation6"></p>
<p>同理，我们计算隐藏单元<code>Hidden2</code>的误差：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.15%20backpropagation7.png" alt="backpropagation7"></p>
<p>同理，我们计算隐藏单元<code>Hidden3</code>的误差：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.16%20backpropagation8.png" alt="backpropagation8"></p>
<p>算完第一个隐藏层的误差之后，我们用这些误差来升级权重值。首先升级连接输入单元与<code>Hidden1</code>的边的权重，以及连接常误差项与<code>Hidden1</code>的边的权重。我们将连接<code>Input1</code>与<code>Hidden1</code>的边的权重<code>Weight1</code>增加学习速率，<code>Hidden1</code>的误差以及<code>Input1</code>的值的乘积。</p>
<p>按同样的方法处理权重<code>Weight2</code>，我们把学习速率，<code>Hidden1</code>的误差以及<code>Input2</code>的值的乘积增加到<code>Weight2</code>。最后，我们计算常误差项输入的权重，把学习速率，<code>Hidden1</code>的误差以及常误差项的值1的乘积增加到常误差项输入的权重，如下图所示：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.17%20backpropagation9.png" alt="backpropagation9"></p>
<p>同理，我们升级连接输入单元与<code>Hidden2</code>的边的权重，以及连接常误差项与<code>Hidden2</code>的边的权重：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.18%20backpropagation10.png" alt="backpropagation10"></p>
<p>同理，我们升级连接输入单元与<code>Hidden3</code>的边的权重，以及连接常误差项与<code>Hidden3</code>的边的权重：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.19%20backpropagation11.png" alt="backpropagation11"></p>
<p>输入层与第一隐藏层之间边的权重全部更新之后，我们可以用同样的方法计算第一隐藏层与第二隐藏层直接边的权重。我们计算权重<code>Weight7</code>，把学习速率，<code>Hidden4</code>的误差以及<code>Hidden1</code>的值的乘积增加到<code>Weight7</code>。同样的方法计算<code>Weight8</code>与<code>Weight15</code>：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.20%20backpropagation12.png" alt="backpropagation12"></p>
<p>连接<code>Hidden5</code>与<code>Hidden6</code>的边的权重按同样的方法升级。升级完两个隐藏层之间的权重之后，我们就来升级第二隐藏层与输出层之间的权重。用同样的方法升级<code>Weight16</code>到<code>Weight21</code>的权重：</p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.21%20backpropagation13.png" alt="backpropagation13"></p>
<p><img src="posts/10-from-the-perceptron-to-artificial-neural-networks/mlslpic/10.22%20backpropagation14.png" alt="backpropagation14"></p>
<p>把学习速率，<code>Output2</code>的误差以及<code>Hidden6</code>的激励的乘积增加到<code>Weight21</code>之后，这个阶段网络权重的更新工作就完成了。我们现在可以用心的权重再运行一遍前向传播，成本函数的值应该会减少。重复这个过程直到模型收敛或者停止条件得到了满足为止。与之前我们介绍过的线性模型不同，反向传播不能优化凸函数。反向传播可能用某个局部最小值的参数值达到收敛，而不是全局最小值。实际应用中，局部最小值通常可以解决问题。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="用多层感知器近似XOR函数">用多层感知器近似XOR函数<a class="anchor-link" href="posts/10-from-the-perceptron-to-artificial-neural-networks/#%E7%94%A8%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E5%99%A8%E8%BF%91%E4%BC%BCXOR%E5%87%BD%E6%95%B0">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>让我们训练一个多层感知器来近似XOR函数。目前，scikit-learn的0.16.1版本还没有合并，作者在其github上提供了单独的MLP模块<a href="https://github.com/IssamLaradji/NeuralNetworks">NeuralNetworks</a>，我们在0.16.1版本基础上稍作修改，即可完成本书的例子。</p>
<blockquote>
<p>请fork作者的NeuralNetworks，将<code>multilayer_perceptron</code>文件夹里的<code>.py</code>文件复制到<code>sklearn/neural_network</code>文件夹里，然后将对<code>__init__.py</code>文件做如下修改即可：</p>
<div class="highlight"><pre><span class="c"># __init__.py</span>
<span class="kn">from</span> <span class="nn">.rbm</span> <span class="kn">import</span> <span class="n">BernoulliRBM</span>

<span class="kn">from</span> <span class="nn">.multilayer_perceptron</span> <span class="kn">import</span> <span class="n">MultilayerPerceptronClassifier</span>
<span class="kn">from</span> <span class="nn">.multilayer_perceptron</span> <span class="kn">import</span> <span class="n">MultilayerPerceptronRegressor</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">"BernoulliRBM"</span><span class="p">,</span>
           <span class="s">"MultilayerPerceptronClassifier"</span><span class="p">,</span>
           <span class="s">"MultilayerPerceptronRegressor"</span><span class="p">]</span>
</pre></div>
<p>另外，在Linux和Mac OS系统里，复制<code>.py</code>文件的权限记得改成<code>chmod 644</code></p>
</blockquote>
<p>首先，我们建议一个简单的二分分类数据集表示XOR，然后用交叉检验分割成训练集和测试集：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.neural_network</span> <span class="kn">import</span> <span class="n">MultilayerPerceptronClassifier</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1000</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>然后，我们将<code>MultilayerPerceptronClassifier</code>类实例化。用<code>n_hidden</code>设置神经网络架构中隐藏层的层数。我们将隐藏层的层数设置为两层。<code>MultilayerPerceptronClassifier</code>类自动创建两个输入单元和一个输出单元。在多元分类问题中分类器会为每一个可能的类型创建一个输出。</p>
<p>选择神经网络架构是很复杂的事情。确定隐藏单元和隐藏层的数量有一些首要原则，但是都没有必然的依据。隐藏单元的数量由样本数量，训练数据的噪声，要被近似的函数复杂性，隐藏单元的激励函数，学习算法和使用的正则化方法决定。实际上，架构的效果只能通过交叉检验得出。</p>
<p>我们通过<code>fit()</code>函数训练模型：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [3]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span class="n">clf</span> <span class="o">=</span> <span class="n">MultilayerPerceptronClassifier</span><span class="p">(</span><span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                    <span class="n">activation</span><span class="o">=</span><span class="s">'logistic'</span><span class="p">,</span>
                                    <span class="n">algorithm</span><span class="o">=</span><span class="s">'sgd'</span><span class="p">,</span>
                                    <span class="n">random_state</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[3]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>MultilayerPerceptronClassifier(activation='logistic', algorithm='sgd',
                alpha=1e-05, batch_size=200, hidden_layer_sizes=[2],
                learning_rate='constant', learning_rate_init=0.5,
                max_iter=200, power_t=0.5, random_state=3, shuffle=False,
                tol=1e-05, verbose=False, warm_start=False)</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>最后，我们打印估计模型对测试集预测的准确率和一些手工输入的预测结果。预测测试集的结果表明，这个人工神经网络可以完美的近似XOR函数：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [5]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span class="k">print</span><span class="p">(</span><span class="s">'层数：</span><span class="si">%s</span><span class="s">，输出单元数量：</span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">n_layers_</span><span class="p">,</span> <span class="n">clf</span><span class="o">.</span><span class="n">n_outputs_</span><span class="p">))</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'准确率：</span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">predictions</span><span class="p">[:</span><span class="mi">10</span><span class="p">]):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'真实值：</span><span class="si">%s</span><span class="s">，预测值：</span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">y_test</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">p</span><span class="p">))</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>层数：3，输出单元数量：1
准确率：1.0
真实值：1，预测值：1
真实值：1，预测值：1
真实值：1，预测值：1
真实值：0，预测值：0
真实值：1，预测值：1
真实值：0，预测值：0
真实值：0，预测值：0
真实值：1，预测值：1
真实值：0，预测值：0
真实值：1，预测值：1
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="手写数字识别">手写数字识别<a class="anchor-link" href="posts/10-from-the-perceptron-to-artificial-neural-networks/#%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>在上一章我们介绍过用支持向量机识别MNIST数据集里面的手写数字。下面我们用人工神经网络来识别：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [6]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_digits</span>
<span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="kn">import</span> <span class="n">train_test_split</span><span class="p">,</span> <span class="n">cross_val_score</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">from</span> <span class="nn">sklearn.neural_network.multilayer_perceptron</span> <span class="kn">import</span> <span class="n">MultilayerPerceptronClassifier</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>首先我们用<code>load_digits</code>函数加载数据集。因为我们要在交叉验证期间拷贝（fork）进程，所以程序要放在<code>main()</code>函数里运行：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [7]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">digits</span> <span class="o">=</span> <span class="n">load_digits</span><span class="p">()</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">digits</span><span class="o">.</span><span class="n">data</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">digits</span><span class="o">.</span><span class="n">target</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>在人工神经网络里，放大特征非常重要，因为这样可以让算法更快的收敛。在用<code>MultilayerPerceptronClassifier</code>训练模型前，我们用<code>Pipeline</code>类放大数据。这个神经网络包括一个输入层和一个输出层，两个隐藏层，其中一个有150个单元，另一个有100个单元。我们还增加了正则化<code>alpha</code>超参数的值。最后，我们打印三个交叉验证组合的预测准确率。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [8]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">([</span>
                    <span class="p">(</span><span class="s">'ss'</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
                    <span class="p">(</span><span class="s">'mlp'</span><span class="p">,</span> <span class="n">MultilayerPerceptronClassifier</span><span class="p">(</span><span class="n">hidden_layer_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">))</span>
                    <span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="s">'准确率： </span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>准确率： [ 0.8654485   0.87646077  0.87248322]
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>人工神经网络的平均准确率与支持向量机一致。增加隐藏单元和隐藏层，运用网格搜索，会进一步提供模型的准确率。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="总结">总结<a class="anchor-link" href="posts/10-from-the-perceptron-to-artificial-neural-networks/#%E6%80%BB%E7%BB%93">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>本章我们介绍了人工神经网络，一种通过人工神经元的组合来表述复杂函数的强大的分类和回归模型。本文介绍的有向无环图称为前馈人工神经网络。多层感知器就是一种前馈人工神经网络，其每一次都完全连接后面一层。带一个隐藏层和若干隐藏单元的MLP是一种通用函数近似器。它可以表示任何连续函数，尽管它未必能够自动的学习到适当的权重。我们还介绍了网络的隐藏层如何表示不可见的变量，以及如何用反向传播算法学习权重。最后，我们用scikit-learn的多次感知器<code>MultilayerPerceptronClassifier</code>类完成了XOR函数近似和MNIST数据集的手写数字识别。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>这是本书的最后一章。我们介绍许多模型，学习算法，效果评估方法，以及这些理论在scikit-learn中的实现。第一章，我们把机器学习描述成一种通过经验改善任务学习效果的过程。然后，我们通过一些例子演示常见的机器学习任务，学习经验和效果评估方法。我们介绍过匹萨价格与直接的回归案例和垃圾短信分类案例。我们通过颜色聚类压缩图片，聚类SURF描述器识别猫和狗的照片。我们用主成分分析做面部识别，用随机森林决策树拦截网页上的广告图片，还用支持向量机和人工神经网络识别手写数字。感谢你的阅读，希望你可以用scikit-learn和书中案例解决自己的问题。</p>

</div>
</div>
</div>
    </div>
  </div>

    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/9-from-the-perceptron-to-support-vector-machines/" class="u-url">9-from-the-perceptron-to-support-vector-machines</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Tao Junjie</span></p>
            <p class="dateline"><a href="posts/9-from-the-perceptron-to-support-vector-machines/" rel="bookmark"><time class="published dt-published" datetime="2015-07-08T09:15:04+08:00" itemprop="datePublished" title="Publication date">2015-07-08 09:15</time></a></p>
                <p class="commentline">            <a href="posts/9-from-the-perceptron-to-support-vector-machines/#disqus_thread" data-disqus-identifier="cache/posts/9-from-the-perceptron-to-support-vector-machines.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div tabindex="-1" id="notebook" class="border-box-sizing">
    <div class="container" id="notebook-container">

<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="从感知器到支持向量机">从感知器到支持向量机<a class="anchor-link" href="posts/9-from-the-perceptron-to-support-vector-machines/#%E4%BB%8E%E6%84%9F%E7%9F%A5%E5%99%A8%E5%88%B0%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA">¶</a>
</h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>上一章我们介绍了感知器。作为一种二元分类器，感知器不能有效的解决线性不可分问题。其实在<em>第二章，线性回归</em>里面已经遇到过类似的问题，当时需要解决一个解释变量与响应变量存在非线性关系的问题。为了提高模型的准确率，我们引入了一种特殊的多元线性回归模型，多项式回归。通过对特征进行合理的组合，我们建立了高维特征空间的解释变量与响应变量的线性关系模型。</p>
<p>随着特征空间的维度的不断增多，在用线性模型近似非线性函数时，上述方法似乎依然可行，但是有两个问题不可避免。首先是计算问题，计算映射的特征，操纵高维的向量需要更强大的计算能力。然后是与算法归纳有关的问题，特征空间的维度的不断增多会导致维度灾难。从高维的特征变量中学习，要避免拟合过度，就需要呈指数级增长的训练数据。</p>
<p>这一章，我们将介绍一种强大的分类和回归模型，称为支持向量机（support vector machine，SVM）。首先，我们将学习高维空间的特征映射。然后，我们将介绍，在处理被映射到高维空间的数据时，支持向量机是如何缓解那些计算与综合问题的。有许多书整本整本的介绍SVM，相关的优化算法需要比前面章节里介绍其他算法更多的数学知识。我们不再用前面那些章节的小例子来演示算法，而是通过直观的案例来介绍scikit-learn如何有效的使用SVM去解决问题。</p>
<!-- TEASER_END-->
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="核与核方法">核与核方法<a class="anchor-link" href="posts/9-from-the-perceptron-to-support-vector-machines/#%E6%A0%B8%E4%B8%8E%E6%A0%B8%E6%96%B9%E6%B3%95">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>感知器是用超平面作决策边界对阳性和阴性类型进行分类的。其决策边界公式如下：</p>
$$f(x)=<w>+b$$<p>预测是通过下面的格式计算得出：</p>
$$h(x)=sign(f(x))$$<p>其中，$<w>$是内积$w^Tx$。为了与SVM的概念一致，我们要对上面的概念做一些调整。</w></p>
<p>我们可以把模型写成另一种形式，其证明过程忽略。下面的模型表达式称为对偶型（dual form）。前面介绍的表达式称为原型（primal form）:</p>
$$f(x)=<w>+b=\sum a_iy_i<x>+b$$<p>对偶型与原型的最重要区别就是原型计算模型参数（model parameters ）内积，测试样本的特征向量，而对偶型计算训练样本（training instances）的内积，测试样本的特征向量。总之，我们将利用对偶型的这个特性来解决线性不可分问题。首先，我们必须定义高维空间特征映射。</p>
<p>在<em>第二章，线性回归</em>介绍多元回归时，我们将特征映射成与响应变量线性相关的高维空间。映射将原来的特征进行组合，通过建立二次项增加特征的数量。这些综合特征允许我们用线性模型表示非线性函数。通常，映射表达式如下所示：</p>
$$x \to \phi(x)$$$$\phi : R^d \to R^D$$<p>下图中左边显示了一个线性不可分数据集。而右边就是将数据集映射到更高维空间后线性可分的结果。</p>
<p><img src="posts/9-from-the-perceptron-to-support-vector-machines/mlslpic/9.1%20mapplot.png" alt="mapplot"></p>

</x></w></w>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>让我们回到决策边界的对偶型，观察特征向量只以点积呈现的情况。我们可以用下面的方法将数据映射到一个高维空间：</p>
$$f(x)=\sum a_iy_i<x>+b$$$$f(x)=\sum a_iy_i+b$$<p>这个映射允许我们表述更复杂的模型，但是它也引入了计算和综合相关的问题。映射特征向量并计算它们的点积需要极大的计算能力。</p>
<p>注意在第二个方程里，我们将特征向量映射到高维空间中，特征向量仍然是以点积呈现。点积是标量，如果一个标量已经被计算出来，我们就不需要去映射对应的特征向量了，这样我们在计算点击和映射特征向量这些事情上省点儿事儿。</p>
<p>有一种方法叫做核方法（ kernel trick）。核是一个考虑原始特征向量的函数，返回对应的映射后特征向量点积相同的值。核不直接将特征向量映射到高维空间，或者计算映射后特征向量点积。而且通过一组更有效的计算步骤得出同样的值。核更正式定义如下：</p>
$$K(x,z)=$$<p>下面我们演示核是如何运行的。假设我们有两特征向量，$x$和$z$：</p>
$$x=(x_1,x_2)$$$$z=(z_1,z_2)$$<p>在我们的模型里面，我们想用下面的转换函数将特征向量映射到高维空间：</p>
$$\phi(x)=x^2$$<p>映射后的标准化特征向量的点积等价于：</p>
$$=$$<p>而下面公式的核可以产生与映射后的特征向量的点积同样的结果：</p>
$$K(x,z)={<x>}^2={(x_1z_1+x_2z_2)}^2=x_1^2z_1^2+2x_1z_1x_2z_2+x_2^2z_2^2$$$$K(x,z)=$$<p>让我们把数值带入公式计算一下，让结果更清楚：</p>
$$x=(4,9)$$$$z=(3,3)$$$$K(x,z)={<x>}^2={(4\times3+9\times3)}^2=4^2\times3^2+2\times4\times3\times9\times3+9^2\times3^2=1521$$$$==1521$$<p>$K(x,z)$与$$映射后的特征向量的点积计算结果相同，但是不需要将特征向量映射到高维空间，这样减少了计算操作。这个例子只用了二维特征向量。具有中等数量特征的数据集经过映射后的特征空间将具有巨大的维度。scikit-learn提供了一些常用的核，包括多项式（polynomial），S形曲线（sigmoid），正态分布（Gaussian）和线性（linear）核。多项式核公司如下：</p>
$$K(x,x')={(1+x \times x')}^k$$<p>平方核，就是多项式核的参数$k$是2的形式，在自然语言处理中经常用到。</p>
<p>S形曲线核公式如下。$\gamma$和$r$是可以通过交叉检验进行调整的超参数：</p>
$$K(x,x')=tanh$$<p>正态分布核是处理非线性问题的首选。正态分布核是一种<a href="https://zh.wikipedia.org/wiki/%E5%BE%84%E5%90%91%E5%9F%BA%E5%87%BD%E6%95%B0%E6%A0%B8">径向基函数（radial basis function）</a>。映射后的特征空间里的超平面形成的决策边界与原始特征空间的超平面形成的决策边界类似。正态分布核产生的特征空间可以有无限维，这点在其他核中是不可能有的。正态分布核公式如下：</p>
$$K(x,x')=exp(- \frac {
\begin{Vmatrix}
x,x'
\end{Vmatrix}
^2 }
{2\sigma ^2})$$<p>其中，$\sigma$是一个超参数。当使用SVM时，通常缩放特征是很重要的，但是使用正态分布核时缩放特征尤其重要。</p>
<p>选择哪种核是很复杂的事情。理想情况下，一个核会以一种有益于解决问题的方式度量样本间的相似度。核经常用于SVM，也可用于任何能够用两个特征向量点积进行表述的模型，包括逻辑回归，感知器和主成分分析。下面，我们将解决由映射到高维特征空间引起的第二个问题：综合。</p>

</x></x></x>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="最大化间隔分类与支持向量">最大化间隔分类与支持向量<a class="anchor-link" href="posts/9-from-the-perceptron-to-support-vector-machines/#%E6%9C%80%E5%A4%A7%E5%8C%96%E9%97%B4%E9%9A%94%E5%88%86%E7%B1%BB%E4%B8%8E%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>下图显示了两种线性可分的类型的样本集和三种可能的决策边界。所有的决策边界都可以把样本集分成阳性与阴性两种类型，感知器可以学习任何一种边界。那么，哪个决策边界对测试集数据的测试效果最好呢？</p>
<p><img src="posts/9-from-the-perceptron-to-support-vector-machines/mlslpic/9.2%20decisionboundaries.png" alt="decisionboundaries"></p>
<p>观察图中三条决策边界，我们会直观的认为点线是最佳边界。实线决策边界接近许多阳性类型样本。测试集中如果包含第一个解释变量$x_1$比较小的阳性样本，这个样本的类型将预测错误。虚线决策边界与大多数训练样本都很远，但是它接近一个阳性类型样本和一个阴性类型样本。下图提供了评估决策边界效果的不同视角：</p>
<p><img src="posts/9-from-the-perceptron-to-support-vector-machines/mlslpic/9.3%20evaluating.png" alt="evaluating"></p>
<p>假设上面画的这条线是一个逻辑回归分类器的决策边界。样本A远离决策边界，较高的概率预测它属于阳性类型。样本B仍然可以预测它属于阳性类型，但是概率可能比远离决策边界的样本A要低。最后，样本C可能以较低的概率预测它属于阳性类型，甚至训练数据集的一点儿小变化都会改变预测结果。最可靠的预测是远离决策边界的样本。我们可以用函数间隔（functional margin）来估计预测的置信水平。训练集的函数间隔公式如下：</p>
$$funct = min(y_if(x_i))$$$$f(x) = <w>+b$$<p>其中，$y_i$是样本的真实类型。样本A的函数间隔比样本C的函数间隔小。如果样本C预测错了，其函数间隔就会是负数。函数间隔为1的样本集称为支持向量（support vectors）。仅这些样本都足以定义决策边界；预测测试集样本的类型时，其他的样本可以不用。函数间隔有关的概念是空间间隔（geometric margin），或称为分离支持向量的带空间的最大宽度。空间间隔等于标准化的函数间隔。有必要用$w$标准化函数间隔，因为间隔在训练时是不确定的。当$w$是一个单位向量时，空间间隔等于函数间隔。现在我们可以把最佳决策边界定义成最大空间间隔。可以通过下面的约束条件求解最大空间间隔时的模型参数：</p>
$$min \frac 1 n <w>$$$$subject to: y_i(<w>+b) \ge 1$$<p>支持向量机的一个有用的属性是这个优化问题是凸包形，其唯一的局部最小值也是全局最小值。这里省略证明过程，前面的优化问题可以用对偶型调整核函数写出如下形式：</p>
$$W(\alpha)=\sum_i {\alpha_i}- \frac 1 2 \sum_{i,j} \alpha_i \alpha_j y_i y_j K(x_i,x_j)$$$$subject to:\sum_{i=1}^n y_i \alpha_i=0$$$$subject to:\alpha_i \ge 0$$<p>求最大化空间间隔的参数的约束是：所有的阳性样本的函数间隔最小为1，所有的阳性样本的函数间隔最多为-1，是一个二次规划问题（quadratic programming problem）。这类问题通常的解法是用序列极小优化（Sequential Minimal Optimization，SMO）算法。SMO算法把优化问题分解成一系列最小化子问题，可以通过解析方法解决。</p>

</w></w></w>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="scikit-learn文字识别">scikit-learn文字识别<a class="anchor-link" href="posts/9-from-the-perceptron-to-support-vector-machines/#scikit-learn%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>下面我们用SVM来解决分类问题。近几年，SVM已经成功解决了文字识别问题。就是给一张图片，分类器需要预测出上面的文字。文字识别是OCR（optical character-recognition，光学识别）系统的一部分。当用原始的像素强度矩阵表示特征向量时，很小的图片也会产生很高维的向量。如果类型是线性不可分，必须被映射到高维空间时，特征空间的维度会变得更庞大。SVM可以有效的处理这些问题。首先，我们用scikit-learn 训练SVM识别手写数字。然后，我们再用SVM识别照片上的字母。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="识别手写数字">识别手写数字<a class="anchor-link" href="posts/9-from-the-perceptron-to-support-vector-machines/#%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97">¶</a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>MNIST手写数字数据库（Mixed National Institute of Standards and Technology database）包含70000张手写数字图片。这些数字是通过美国国家统计局的员工和美国高校的学生收集的。每张图片都是28x28的灰度图。让我们取一些图看看：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="o">%</span><span class="k">matplotlib</span> inline
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="k">import</span> <span class="n">fetch_mldata</span>
<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="k">as</span> <span class="nn">cm</span>

<span class="n">digits</span> <span class="o">=</span> <span class="n">fetch_mldata</span><span class="p">(</span><span class="s">'MNIST original'</span><span class="p">,</span> <span class="n">data_home</span><span class="o">=</span><span class="s">'data/mnist'</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>

<span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">digits</span><span class="p">[(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8000</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)),</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">Greys_r</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s">'off'</span><span class="p">)</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>


<div class="output_png output_subarea ">
<img src="data:image/png;base64,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%0Agg==">
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>首先，我们加载数据。scikit-learn提供了<code>fetch_mldata</code>函数下载数据，然后读入对象。然后，我们创建subplot分别显示0，1，2的5个样本。</p>
<p>MNIST数据集可以分成60000张图片的训练集和10000张图片的测试集。这个数据集经常用于估计机器学习模型的效果；训练模型前总需要一点预处理，所以这个数据集很受欢迎。让我们用scikit-learn建一个分类器来预测图片的数字。</p>
<p>首先，导入需要用的模块：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="k">import</span> <span class="n">fetch_mldata</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="k">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="k">import</span> <span class="n">scale</span>
<span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="k">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="k">import</span> <span class="n">SVC</span>
<span class="kn">from</span> <span class="nn">sklearn.grid_search</span> <span class="k">import</span> <span class="n">GridSearchCV</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">classification_report</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>然后用<code>fetch_mldata</code>函数导入数据。再放大特征值，然后把图像调整到原点为中心的位置。再用交叉检验分割数据集：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [2]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">data</span> <span class="o">=</span> <span class="n">fetch_mldata</span><span class="p">(</span><span class="s">'MNIST original'</span><span class="p">,</span> <span class="n">data_home</span><span class="o">=</span><span class="s">'data\mnist'</span><span class="p">)</span>
<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">target</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">/</span><span class="mf">255.0</span><span class="o">*</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>之后，我们实例化一个<code>SVC</code>类的对象，就是支持向量分类器。这个对象的API和scikit-learn的其他估计器差不多；分类器用<code>fit</code>函数训练，然后用<code>predict</code>函数预测结果。如果你看过<code>SVC</code>的文档内容，你会发现它的参数与其他估计器要多一个。<code>SVC</code>最有意思的超参数是<code>kernel</code>，<code>C</code>和<code>gamma</code>。<code>kernel</code>是核函数类型。scikit-learn提供了线性，多项式，S形曲线，和RBF（径向基函数）核。<code>C</code>是控制正则化的参数，类似逻辑回归里的$\lambda$超参数。<code>gamma</code>是多项式，S形曲线，和RBF核的相关系数。超参数的设置很难恰到好处，所以我们用网格搜索来计算：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="c"># clf = SVC(kernel='rbf', C=2.8, gamma=.0073)</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">([</span>
    <span class="p">(</span><span class="s">'clf'</span><span class="p">,</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s">'rbf'</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mi">100</span><span class="p">))</span>
<span class="p">])</span>
<span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'clf__gamma'</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="s">'clf__C'</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span>
<span class="p">}</span>
<span class="c"># TODO is refit true by default?</span>
<span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s">'accuracy'</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
<span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'最佳效果：%0.3f'</span> <span class="o">%</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_score_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'最优参数集：'</span><span class="p">)</span>
<span class="n">best_arameters</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_estimator_</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
<span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">'</span><span class="se">\t</span><span class="s">%s: %r'</span> <span class="o">%</span> <span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">best_parameters</span><span class="p">[</span><span class="n">param_name</span><span class="p">]))</span>
<span class="n">predictios</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">predictions</span><span class="p">))</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">

<pre><code>Fitting 3 folds for each of 30 candidates, totalling 90 fits
[Parallel(n_jobs=2)]: Done 1 jobs | elapsed: 7.7min
[Parallel(n_jobs=2)]: Done 50 jobs | elapsed: 201.2min
[Parallel(n_jobs=2)]: Done 88 out of 90 | elapsed: 304.8min
remaining: 6.9min
[Parallel(n_jobs=2)]: Done 90 out of 90 | elapsed: 309.2min finished
Best score: 0.966
Best parameters set:
    clf__C: 3
    clf__gamma: 0.01
        precision recall f1-score support
        0.0 0.98 0.99 0.99 1758
        1.0 0.98 0.99 0.98 1968
        2.0 0.95 0.97 0.96 1727
        3.0 0.97 0.95 0.96 1803
        4.0 0.97 0.98 0.97 1714
        5.0 0.96 0.96 0.96 1535
        6.0 0.98 0.98 0.98 1758
        7.0 0.97 0.96 0.97 1840
        8.0 0.95 0.96 0.96 1668
        9.0 0.96 0.95 0.96 1729
avg / total 0.97 0.97 0.97 17500</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>模型预测的最佳综合指标是0.97，增大训练样本量可以继续改善效果，不过对硬件的要求依然很高，在我的电脑上i5 cpu 16G RAM上跑了309分钟。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="自然图片文字识别">自然图片文字识别<a class="anchor-link" href="posts/9-from-the-perceptron-to-support-vector-machines/#%E8%87%AA%E7%84%B6%E5%9B%BE%E7%89%87%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB">¶</a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>现在，我们再做一个更具挑战性的任务。我们将从自然图片中识别英文字母。<a href="http://www.ee.surrey.ac.uk/CVSSP/demos/chars74k">Chars74K数据集</a>是T. E. de Campos，B. R. Babu和M. Varma为《Character Recognition in Natural Images》提供的74000张图片，包括0到9的数字和26个英文字母。下面是小写字母<code>z</code>的三个示例图片：</p>
<p><img src="posts/9-from-the-perceptron-to-support-vector-machines/mlslpic/9.4%20z.png" alt="z"></p>
<p>这个数据集包含不同的图片类型。本例使用从印度的Bangalore拍摄的街景里抽取的7705张文字图片。与MNIST数据集不同，Chars74K数据集里面的这些图片中的文字具有不同的字体，颜色和变化。数据下载完成后，我们将用<code>English/Img/GoodImg/Bmp/</code>里面的图片。首先我们导入模块</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">mahotas</span> <span class="k">as</span> <span class="nn">mh</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="k">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="k">import</span> <span class="n">SVC</span>
<span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="k">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.grid_search</span> <span class="k">import</span> <span class="n">GridSearchCV</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">classification_report</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>然后我们用mahotas库将图片转换成同样大小和颜色。与MNIST数据集不同，Chars74K数据集里面的图片大小不同，我们将图片转换成一边为30px的图片。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">X</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">path</span><span class="p">,</span> <span class="n">subdirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="s">'data/English/Img/GoodImg/Bmp/'</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">filename</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="n">filename</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">'-'</span><span class="p">)]</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">mh</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">as_grey</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">30</span> <span class="ow">or</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">30</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">img_resized</span> <span class="o">=</span> <span class="n">mh</span><span class="o">.</span><span class="n">imresize</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">img_resized</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">):</span>
            <span class="n">img_resized</span> <span class="o">=</span> <span class="n">mh</span><span class="o">.</span><span class="n">imresize</span><span class="p">(</span><span class="n">img_resized</span><span class="p">,</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
        <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_resized</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">900</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>最后我们把图片转换成Numpy数组，建立<code>SVC</code>模型，训练并预测：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=.</span><span class="mi">1</span><span class="p">)</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">([</span>
    <span class="p">(</span><span class="s">'clf'</span><span class="p">,</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s">'rbf'</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mi">100</span><span class="p">))</span>
<span class="p">])</span>
<span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'clf__gamma'</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="s">'clf__C'</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span>
<span class="p">}</span>
<span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s">'accuracy'</span><span class="p">)</span>
<span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'最佳效果：%0.3f'</span> <span class="o">%</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_score_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'最优参数集：'</span><span class="p">)</span>
<span class="n">best_parameters</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_estimator_</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
<span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">'</span><span class="se">\t</span><span class="s">%s: %r'</span> <span class="o">%</span> <span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">best_parameters</span><span class="p">[</span><span class="n">param_name</span><span class="p">]))</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">predictions</span><span class="p">))</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>这个任务比识别MNIST数据集里面的手写数据需要耗费更多的计算能力。字母的外形变化很大，因为这些字母都是从照片里提取的，不是扫描件。另外，Chars74K数据集里每个类型的训练样本数量比MNIST数据集更少。分类器的性能可以通过增加训练数据，用另外的图片预处理方法，或者用更复杂的特征表述等手段来改善。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="总结">总结<a class="anchor-link" href="posts/9-from-the-perceptron-to-support-vector-machines/#%E6%80%BB%E7%BB%93">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>本章，我们介绍了支持向量机——一种可以弥补感知器不足的强大模型。感知器可以有效的处理线性可分问题模型，但是如果不把特征空间扩展到更高的维度，它不能表达更复杂的决策边界。但是，这样的扩展会导致计算与综合相关的问题。支持向量机用核函数修正第一个问题，可以避免特征映射的复杂计算，通过决策边界与最近样本的间隔最大化修正第二个问题。下一章，我们将介绍人工神经网络模型，和支持向量机一样，可以弥补感知器的不足。</p>

</div>
</div>
</div>
    </div>
  </div>

    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/8-the-perceptron/" class="u-url">8-the-perceptron</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Tao Junjie</span></p>
            <p class="dateline"><a href="posts/8-the-perceptron/" rel="bookmark"><time class="published dt-published" datetime="2015-07-08T09:13:39+08:00" itemprop="datePublished" title="Publication date">2015-07-08 09:13</time></a></p>
                <p class="commentline">            <a href="posts/8-the-perceptron/#disqus_thread" data-disqus-identifier="cache/posts/8-the-perceptron.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div tabindex="-1" id="notebook" class="border-box-sizing">
    <div class="container" id="notebook-container">

<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="感知器">感知器<a class="anchor-link" href="posts/8-the-perceptron/#%E6%84%9F%E7%9F%A5%E5%99%A8">¶</a>
</h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>前面，我们介绍了广义线性模型，用联接方程描述解释变量、超参数和响应变量的线性关系。这一章，我们将介绍另一种线性模型，称为感知器（perceptron）。感知器是一种研究单个训练样本的二元分类器，训练较大的数据集很有用。而且，感知器和它的不足激发了我们后面两种将介绍的模型。</p>
<!-- TEASER_END-->
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>感知器是Frank Rosenblatt在1957年就职于Cornell航空实验室(Cornell Aeronautical Laboratory)时发明的，其灵感源自于对人脑的仿真。大脑是由处理信息的神经元（neurons）细胞和连接神经元细胞进行信息传递的突触（synapses）构成。据说人脑有1千亿神经元和10万亿突触构成。神经元的组成如下图所示，主要包括树突（Dendrites），细胞核（Cell Body）和轴突（Axon）。树突从一个神经元接受电信号。信号在细胞核里处理，然后通过轴突将处理过的信号传递给另一个神经元。</p>
<p><img src="posts/8-the-perceptron/mlslpic/8.1%20neurons.png" alt="neurons"></p>
<p>一个神经元可以看作是将一个或多个输入处理成一个输出的计算单元。一个感知器函数类似于一个神经元；它接受一个或多个输入，处理他们然后返回一个输出。咋看这样的模型，就像人脑千亿神经元的一个孤胆英雄，无用武之地。但是，有两个理由使得我们有必要介绍它。首先，神经元可以实时(online)，错误驱动(error-driven)的学习，神经元可以通过一一个的训练样本不断更新参数，而非一次性使用整套数据。实时学习可能有效的处理内存无法容纳的大数据。其次，理解感知器的工作原理是后两章算法学习的基础，包括支持向量机（support vector machines）和人工神经网络（artificial neural networks）。感知器通常用下面的图形表示：</p>
<p><img src="posts/8-the-perceptron/mlslpic/8.2%20perceptrons.png" alt="perceptrons"></p>
<p>$x_1$，$x_2$和$x_3$是输入单元。每个输入单元分别代表一个特征。感知器通常用另外一个输入单元代表一个常用误差项，但是这个输入单元在图形中通常被忽略了。中间的圆圈是一个计算单元，类似神经元的细胞核。连接输入单元和计算单元的边类似于树突。每条边是一个权重，或者是一个参数。参数容易解释，如果某个解释变量与阳性类型（positive class）相关，其权重为正，某个解释变量与阴性类型（negative class）相关，其权重为负。连接计算单元和输出单元的边类似轴突。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="激励函数">激励函数<a class="anchor-link" href="posts/8-the-perceptron/#%E6%BF%80%E5%8A%B1%E5%87%BD%E6%95%B0">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>感知器通过使用激励函数（activation function ）处理解释变量和模型参数的线性组合对样本分类，计算公式如下所示。解释变量和模型参数的线性组合有时也称为感知器的预激励（preactivation）。</p>
$$y=\phi(\sum_{i=1}^n{w_ix_i}+b)$$<p>其中，$w_i$是模型参数，$b$是常误差项，$\phi()$是激励方程。常用的激励方程有几种。Rosenblatt最初的感知器用的是阶跃函数（Heaviside step function或unit step function）作为激励函数。函数公式如下所示：</p>
$$
g(x)=
\begin{Bmatrix}
1, x&gt;0 \\
0, x \le 0 \\
\end{Bmatrix}
$$<p>如果加权解释变量的和加上常误差项之和大于0，则激励方程返回1，此时感知器就把样本归类为阳性。否则，激励方程返回0，感知器就把样本归类为阴性。阶跃函数图形如下所示：</p>
<p><img src="posts/8-the-perceptron/mlslpic/8.3%20step.png" alt="step"></p>
<p>另一个常用的激励函数是逻辑S形（logistic sigmoid ）激励函数。这个激励函数的梯度分布可以更有效的计算，在处理后面的ANN算法时十分有效。其计算公式如下：</p>
$$g(x)= \frac 1 {1+e^{-x}}$$<p>其中，$x$是加权输入的和。这个模型与第四章的逻辑方程类似，是解释变量值与模型参数的线性组合，与逻辑回归模型是一样的。虽然用逻辑S形激励函数的感知器与逻辑回归是一样的，但是要估计的参数不同。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="感知器学习算法">感知器学习算法<a class="anchor-link" href="posts/8-the-perceptron/#%E6%84%9F%E7%9F%A5%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95">¶</a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>感知器学习算法首先需要将权重设置为0或很小的随机数，然后预测训练样本的类型。感知器是一种错误驱动（error-driven）的学习算法。如果感知器是正确的，算法就继续处理下一个样本。如果感知器是错误的，算法就更新权重，重新预测。权重的更新规则如下：</p>
$$w_i(t+1) = w_i(t) + \alpha (d_j-y_j(t))x_{j,i},0 \le i \le n$$<p>对每个训练样本来说，每个解释变量的参数值增加$\alpha (d_j-y_j(t))x_{j,i}$，$d_j$是样本$j$的真实类型，$y_j(t)$是样本$j$的预测类型，$x_{j,i}$是第$i$个样本$j$的解释变量的值，$\alpha$是控制学习速率的超参数。如果预测是正确的，$d_j-y_j(t)$等于0，$\alpha (d_j-y_j(t))x_{j,i}$也是0，此时，权重不更新。如预测是错误的，权重会按照学习速率，$d_j-y_j(t)$与解释变量值的乘积增加。</p>
<p>这里的更新规则与梯度下降法中的权重更新规则类似，都是朝着使样本得到正确分类更新，且更新的幅度是由学习速率控制的。每遍历一次训练样本称为完成了一世代（epoch）。如果学习完一世代后，所有的样本都分类正确，那么算法就会收敛（converge）。学习算法不能保证收敛；后面的章节，我们会介绍线性不可分数据集，是不可能收敛的。因此，学习算法还需要一个超参数，在算法终止前需要更新的最大世代数。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="感知器二元分类">感知器二元分类<a class="anchor-link" href="posts/8-the-perceptron/#%E6%84%9F%E7%9F%A5%E5%99%A8%E4%BA%8C%E5%85%83%E5%88%86%E7%B1%BB">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>下面我们来解决一个分类案例。假设你想从一堆猫里分辨幼猫（kitten）和成年猫（adult cats）。数据集只有两个解释变量：用来睡觉的天数比例，闹脾气的天数比例。训练数据由下面四个样本构成：</p>
<table>
<thead><tr>
<th style="text-align:center">样本</th>
<th style="text-align:center">用来睡觉的天数比例</th>
<th style="text-align:center">闹脾气的天数比例</th>
<th style="text-align:center">幼猫还是成年猫？</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0.2</td>
<td style="text-align:center">0.1</td>
<td style="text-align:center">幼猫</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0.4</td>
<td style="text-align:center">0.6</td>
<td style="text-align:center">幼猫</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0.5</td>
<td style="text-align:center">0.2</td>
<td style="text-align:center">幼猫</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">0.7</td>
<td style="text-align:center">0.9</td>
<td style="text-align:center">成年猫</td>
</tr>
</tbody>
</table>
<p>下面的散点图表面这些样本是可以线性分离的：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [2]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="o">%</span><span class="k">matplotlib</span> inline
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.font_manager</span> <span class="k">import</span> <span class="n">FontProperties</span>
<span class="n">font</span> <span class="o">=</span> <span class="n">FontProperties</span><span class="p">(</span><span class="n">fname</span><span class="o">=</span><span class="s">r"c:\windows\fonts\msyh.ttc"</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [3]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]</span>
<span class="p">])</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

<span class="n">markers</span> <span class="o">=</span> <span class="p">[</span><span class="s">'.'</span><span class="p">,</span> <span class="s">'x'</span><span class="p">]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s">'x'</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'用来睡觉的天数比例'</span><span class="p">,</span><span class="n">fontproperties</span><span class="o">=</span><span class="n">font</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'闹脾气的天数比例'</span><span class="p">,</span><span class="n">fontproperties</span><span class="o">=</span><span class="n">font</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'幼猫和成年猫'</span><span class="p">,</span><span class="n">fontproperties</span><span class="o">=</span><span class="n">font</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>


<div class="output_png output_subarea ">
<img src="data:image/png;base64,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%0A9K6axzeRdKWkn0v6b0mv70ZdERExuI5fByFpTeBWYG/gTuA64FDbNzfsMxdY2/a7JW1S7T/N9sqm%0AY+U6iIiIYern6yBmAott32F7BXABsH/TPr8DNqhubwD8sTkcIiKiuyZ14TU2B5Y03F8KvLBpn7OB%0AeZLuAtanTH4VERE91I2AaOcc1nuAn9ueJemZwNWSdrS9vHnH6nTUgAW2F4xNmRER44OkWcCs0R6n%0AGwFxJzC94f50Siui0a7ARwFs/1rS7cDfAdc3H8z23M6UGRExPlRfnBcM3Jf0gZEcpxt9ENcDMyRt%0AJWkt4GDgsqZ9bqF0YiNpGiUc/rcLtUVExCA63oKwvVLS8cBVwJrAObZvlnRM9fhZwKnAeZJupITW%0ASbb/1OnaIiJicJnuOyJinOvnYa4REbEaSkBEREStBERERNRKQERERK0ERERE1EpARERErQRERETU%0ASkBEREStBERERNRKQERERK0ERERE1EpARERErQRERETUSkBEREStBERERNRKQERERK0ERERE1EpA%0ARERErQRERETUSkBEREStBERERNRKQERERK0ERERE1EpARERErUlDPSjpyCEefhz4me1fjW1JERHR%0AD1q1IP4CPDLIPwPndLS6iIjoGdkeegfpncB2zdttHyXpGtu7daq4mlpsW916vYiI8WCkn51DBoSk%0A04F3AzsBTwFuAP4MYHuZpI1t3zeykocvARERMXwj/ewcsg8C2Mn2Q5L2B9YC3gQ8CHwB+H43wyEi%0AIrqrVQviT8AlwAzgBOAh4NPA7cDawJtsr+xCnQP1pAURETFMnTrFdA1wBLA7sD+lxXGa7R9JmgO8%0A1PZBI6x52BIQERHDN+anmCSJ0uewCXAhcBGwDbCPpBuAC4CfjKzciIjod61aEDsDBwKHABsClwGP%0ANe5j+6hOFthUT1oQERHD1JFTTA0HXwuYA+wKHGf7geGXOHoJiIiI4etYQEg6Cviq7RUN284FpgHn%0A2v76cF90pBIQMRzVadI9gZnVpkXAPLfzrShiHOlkQLwV2As4YGDEkqRJwFbAJbaf20Zxs4HPAmsC%0AX7T98Zp9ZgGfASYDf7A9q2afBES0RdIeMPUrMG0DeNW6Zes3HoF774flR9ie39sKI7qn06eY5gAv%0Atn100/aWV1JLWhO4FdgbuBO4DjjU9s0N+2wE/IgyKmqppE1s/6HmWAmIaKkKh2/DhVNgNjDwK2Pg%0A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%0AAiIiImr9Hy6EfJw7vrgGAAAAAElFTkSuQmCC">
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>我们的目标是训练一个感知器可以用两个解释变量分辨猫的类型。我们用阳性表示幼猫，用阴性表示成年猫。用感知网络图（preceding network diagram）可以呈现感知器训练的过程。</p>
<p>我们的感知器有三个输入单元。$x_1$是常误差项，$x_2$和$x_3$是两个特征的输入项。我们的感知器的计算单元用一个阶跃函数表示。本例中，我们把最大的训练世代数设置为10；如果算法经过10世代没有收敛，就会停止返回当时的权重值。为了简化，我们把训练速率设置为1。首先，我们把所有的权重设置为0。第一代的训练结果如下表所示：</p>
<table>
<thead><tr>
<th style="text-align:center">世代1</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th></th>
<th></th>
</tr></thead>
<tbody>
<tr>
<td style="text-align:center">样本</td>
<td style="text-align:center">初始权重</td>
<td style="text-align:center">$x_i$</td>
<td style="text-align:center">激励函数值</td>
<td style="text-align:center">预测值，目标值</td>
<td>是否正确</td>
<td>升级权重</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0, 0, 0</td>
<td style="text-align:center">1.0, 0.2, 0.1</td>
<td style="text-align:center">1.0 * 0 + 0.2 * 0 + 0.1 * 0 = 0.0</td>
<td style="text-align:center">0, 1</td>
<td>False</td>
<td>1.0, 0.2, 0.1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1.0, 0.2, 0.1</td>
<td style="text-align:center">1.0, 0.4, 0.6</td>
<td style="text-align:center">1.0 * 1.0 + 0.4 * 0.2 + 0.6 * 0.1 = 1.14</td>
<td style="text-align:center">1, 1</td>
<td>True</td>
<td>1.0, 0.2, 0.1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1.0, 0.2, 0.1</td>
<td style="text-align:center">1.0, 0.5, 0.2</td>
<td style="text-align:center">1.0 * 1.0 + 0.5 * 0.2 + 0.2 * 0.1 = 1.12</td>
<td style="text-align:center">1, 1</td>
<td>True</td>
<td>1.0, 0.2, 0.1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1.0, 0.2, 0.1</td>
<td style="text-align:center">1.0, 0.7, 0.9</td>
<td style="text-align:center">1.0 * 1.0 + 0.7 * 0.2 + 0.9 * 0.1 = 1.23</td>
<td style="text-align:center">1, 0</td>
<td>False</td>
<td>0, -0.5, -0.8</td>
</tr>
</tbody>
</table>
<p>开始所有权重为0。第一个变量的解释变量加权之和为0，则激励函数值为0，因此样本的预测结果为阴性，即幼猫样本是成年猫类型。预测错误，所以我们要根据规则升级权重。我们将每个输入单元的权重增加，增加幅度为学习速率，真实类型与预测类型的差异值与对应解释变量的值的乘积。</p>
<p>然后用更新的权重预测第二个样本类型。这次解释变量加权之和为1.14，激励函数值为1，真实类型为1，所以类型判断正确。于是继续对第三个样本进行预测，解释变量加权之和为1.12，激励函数值为1，真实类型为1，所以类型判断正确。再对第四个样本进行预测，这次解释变量加权之和为1.23，激励函数值为1，真实类型为0，所以类型判断错误。于是我们更新权重，这样就完成了第一代的训练集样本分类。感知器没有收敛，只有一半样本预测正确。第一代训练完成，决策边界如下图所示：</p>
<p><img src="posts/8-the-perceptron/mlslpic/8.4%20epoch1.png" alt="epoch1"></p>
<p>注意决策边界在整个世代中不断移动；在某个世代结束后由权重构成的决策边界不一定必然与前一世代产生同样的预测值。由于我们还没超过10个世代，所以我们还可以继续训练样本。第二世代的计算过程如下表所示：</p>
<table>
<thead><tr>
<th style="text-align:center">世代2</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th></th>
<th></th>
</tr></thead>
<tbody>
<tr>
<td style="text-align:center">样本</td>
<td style="text-align:center">初始权重</td>
<td style="text-align:center">$x_i$</td>
<td style="text-align:center">激励函数值</td>
<td style="text-align:center">预测值，目标值</td>
<td>是否正确</td>
<td>升级权重</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0, -0.5, -0.8</td>
<td style="text-align:center">1.0, 0.2, 0.1</td>
<td style="text-align:center">1.0<em>0 + 0.2</em>-0.5 + 0.1*-0.8 = -0.18</td>
<td style="text-align:center">0, 1</td>
<td>False</td>
<td>1, -0.3, -0.7</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1, -0.3, -0.7</td>
<td style="text-align:center">1.0, 0.4, 0.6</td>
<td style="text-align:center">1.0<em>1.0 + 0.4</em>-0.3 + 0.6*-0.7 = 0.46</td>
<td style="text-align:center">1, 1</td>
<td>True</td>
<td>1, -0.3, -0.7</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1, -0.3, -0.7</td>
<td style="text-align:center">1.0, 0.5, 0.2</td>
<td style="text-align:center">1.0<em>1.0 + 0.5</em>-0.3 + 0.2*-0.7 = 0.71</td>
<td style="text-align:center">1, 1</td>
<td>True</td>
<td>1, -0.3, -0.7</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1, -0.3, -0.7</td>
<td style="text-align:center">1.0, 0.7, 0.9</td>
<td style="text-align:center">1.0<em>1.0 + 0.7</em>-0.3 + 0.9*-0.7 = 0.16</td>
<td style="text-align:center">1, 0</td>
<td>False</td>
<td>0, -1, -1.6</td>
</tr>
</tbody>
</table>
<p>第2世代开始用的是第1世代的权重。这个世代里有两个训练样本被预测错误。权重升级两次，但是这个世代结束时的决策边界与上个世代结束时的决策边界类似。</p>
<p><img src="posts/8-the-perceptron/mlslpic/8.5%20epoch2.png" alt="epoch2"></p>
<p>这个世代结束是算法依然没有收敛，所有我们要继续训练。第3个世代的训练结果如下表所示：</p>
<table>
<thead><tr>
<th style="text-align:center">世代3</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th></th>
<th></th>
</tr></thead>
<tbody>
<tr>
<td style="text-align:center">样本</td>
<td style="text-align:center">初始权重</td>
<td style="text-align:center">$x_i$</td>
<td style="text-align:center">激励函数值</td>
<td style="text-align:center">预测值，目标值</td>
<td>是否正确</td>
<td>升级权重</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0, -1, -1.6</td>
<td style="text-align:center">1.0, 0.2, 0.1</td>
<td style="text-align:center">1.0<em>0 + 0.2</em>-1.0 + 0.1*-1.6 = -0.36</td>
<td style="text-align:center">0, 1</td>
<td>False</td>
<td>1,-0.8, -1.5</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1,-0.8, -1.5</td>
<td style="text-align:center">1.0, 0.4, 0.6</td>
<td style="text-align:center">1.0<em>1.0 + 0.4</em>-0.8 + 0.6*-1.5 = -0.22</td>
<td style="text-align:center">0, 1</td>
<td>False</td>
<td>2, -0.4, -0.9</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">2, -0.4, -0.9</td>
<td style="text-align:center">1.0, 0.5, 0.2</td>
<td style="text-align:center">1.0<em>2.0 + 0.5</em>-0.4 + 0.2*-0.9 = 1.62</td>
<td style="text-align:center">1, 1</td>
<td>True</td>
<td>2, -0.4, -0.9</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">2, -0.4, -0.9</td>
<td style="text-align:center">1.0, 0.7, 0.9</td>
<td style="text-align:center">1.0<em>2.0 + 0.7</em>-0.4 + 0.9*-0.9 = 0.91</td>
<td style="text-align:center">1, 0</td>
<td>False</td>
<td>1, -1.1, -1.8</td>
</tr>
</tbody>
</table>
<p>感知器这个世代比前面世代预测的效果更差。第3个世代的决策边界如下图所示：</p>
<p><img src="posts/8-the-perceptron/mlslpic/8.6%20epoch3.png" alt="epoch3"></p>
<p>感知器继续更新权重进行第4代和第5代的训练，仍然有预测错误的样本。直到第6代，所有的样本都预测正确了，此时算法达到了收敛状态。第6个世代的训练结果如下表所示：</p>
<table>
<thead><tr>
<th style="text-align:center">世代4</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th></th>
<th></th>
</tr></thead>
<tbody>
<tr>
<td style="text-align:center">样本</td>
<td style="text-align:center">初始权重</td>
<td style="text-align:center">$x_i$</td>
<td style="text-align:center">激励函数值</td>
<td style="text-align:center">预测值，目标值</td>
<td>是否正确</td>
<td>升级权重</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">2, -1, -1.5</td>
<td style="text-align:center">1.0, 0.2, 0.1</td>
<td style="text-align:center">1.0<em>2 + 0.2</em>-1 + 0.1*-1.5 = 1.65</td>
<td style="text-align:center">1, 1</td>
<td>True</td>
<td>2, -1, -1.5</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2, -1, -1.5</td>
<td style="text-align:center">1.0, 0.4, 0.6</td>
<td style="text-align:center">1.0<em>2 + 0.4</em>-1 + 0.6*-1.5 = 0.70</td>
<td style="text-align:center">1, 1</td>
<td>True</td>
<td>2, -1, -1.5</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">2, -1, -1.5</td>
<td style="text-align:center">1.0, 0.5, 0.2</td>
<td style="text-align:center">1.0<em>2 + 0.5</em>-1 + 0.2*-1.5 = 1.2</td>
<td style="text-align:center">1, 1</td>
<td>True</td>
<td>2, -1, -1.5</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">2, -1, -1.5</td>
<td style="text-align:center">1.0, 0.7, 0.9</td>
<td style="text-align:center">1.0<em>2 + 0.7</em>-1 + 0.9*-1.5 = -0.05</td>
<td style="text-align:center">0, 0</td>
<td>True</td>
<td>2, -1, -1.5</td>
</tr>
</tbody>
</table>
<p>第6个世代的决策边界如下图所示：</p>
<p><img src="posts/8-the-perceptron/mlslpic/8.7%20epoch6.png" alt="epoch6"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="感知器解决文档分类">感知器解决文档分类<a class="anchor-link" href="posts/8-the-perceptron/#%E6%84%9F%E7%9F%A5%E5%99%A8%E8%A7%A3%E5%86%B3%E6%96%87%E6%A1%A3%E5%88%86%E7%B1%BB">¶</a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>scikit-learn 提供了感知器功能。和我们用过的其他功能类似，<code>Perceptron</code>类的构造器接受超参数设置。<code>Perceptron</code>类有<code>fit_transform()</code>和<code>predict()</code>方法。<code>Perceptron</code>类还提供了<code>partial_fit()</code>方法，允许分类器训练流式数据（streaming data）并做出预测。</p>
<p>在下面的例子中，我们训练一个感知器对20个新闻类别的数据集进行分类。这个数据集从20个网络新闻网站收集了近2万篇新闻。这个数据集经常用来进行文档分类和聚类实验；scikit-learn提供了下载和读取数据集的简便方法。我们将训练一个感知器识别三个新闻类别：<code>rec.sports.hockey</code>， <code>rec.sports.baseball</code>和<code>rec.auto</code>。scikit-learn的<code>Perceptron</code>也支持多类分类，使用<code>one versus all</code>策略为训练集中的每个类型训练分类器。我们将用TF-IDF加权词袋来表示新闻文档。<code>partial_fit()</code>方法可以连接<code>HashingVectorizer</code>在内存有限的情况下训练较大的流式数据：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [6]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="k">import</span> <span class="n">fetch_20newsgroups</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">f1_score</span><span class="p">,</span> <span class="n">classification_report</span>
<span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="k">import</span> <span class="n">TfidfVectorizer</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="k">import</span> <span class="n">Perceptron</span>
<span class="n">categories</span> <span class="o">=</span> <span class="p">[</span><span class="s">'rec.sport.hockey'</span><span class="p">,</span> <span class="s">'rec.sport.baseball'</span><span class="p">,</span> <span class="s">'rec.autos'</span><span class="p">]</span>
<span class="n">newsgroups_train</span> <span class="o">=</span> <span class="n">fetch_20newsgroups</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="s">'train'</span><span class="p">,</span> <span class="n">categories</span><span class="o">=</span><span class="n">categories</span><span class="p">,</span> <span class="n">remove</span><span class="o">=</span><span class="p">(</span><span class="s">'headers'</span><span class="p">,</span> <span class="s">'footers'</span><span class="p">,</span> <span class="s">'quotes'</span><span class="p">))</span>
<span class="n">newsgroups_test</span> <span class="o">=</span> <span class="n">fetch_20newsgroups</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="s">'test'</span><span class="p">,</span> <span class="n">categories</span><span class="o">=</span><span class="n">categories</span><span class="p">,</span> <span class="n">remove</span><span class="o">=</span><span class="p">(</span><span class="s">'headers'</span><span class="p">,</span> <span class="s">'footers'</span><span class="p">,</span> <span class="s">'quotes'</span><span class="p">))</span>

<span class="n">vectorizer</span> <span class="o">=</span> <span class="n">TfidfVectorizer</span><span class="p">()</span>
<span class="n">X_train</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">newsgroups_train</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">newsgroups_test</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

<span class="n">classifier</span> <span class="o">=</span> <span class="n">Perceptron</span><span class="p">(</span><span class="n">n_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">eta0</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">classifier</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">newsgroups_train</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">newsgroups_test</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">predictions</span><span class="p">))</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>             precision    recall  f1-score   support

          0       0.85      0.92      0.89       396
          1       0.85      0.81      0.83       397
          2       0.89      0.86      0.87       399

avg / total       0.86      0.86      0.86      1192

</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>首先，我们用<code>fetch_20newsgroups()</code>下载并读取数据。和其他内建数据集一致，这个函数返回的对象包括<code>data</code>，<code>target</code>和<code>target_names</code>属性。我们还去掉了每篇文章的页眉，页脚和引用文献。保留那些让分类更容易的解释变量。我们用<code>TfidfVectorizer</code>生成TF-IDF矢量，训练感知器，然后用测试集评估效果。没有用网格搜索优化超参数，感知器的平均精确率，召回率和综合评价指标达到0.86。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="感知器的不足">感知器的不足<a class="anchor-link" href="posts/8-the-perceptron/#%E6%84%9F%E7%9F%A5%E5%99%A8%E7%9A%84%E4%B8%8D%E8%B6%B3">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>虽然我们的例子中感知器的分类效果不错，但是模型仍有一些不足。带阶跃激励函数的感知器线性模型并非通用的函数近似器（universal function approximators）；有一些函数特征是无法表现的。具体来说，线性模型只能学习如何近似线性可分（linearly separable）数据集的函数。我们介绍过的分类器都找到一个超平面将阳性类型与阴性类型区分开来，如果没有一个超平面可以区分两种类型，问题就不是线性可分的。</p>
<p>线性不可分函数的一个简单例子就是逻辑运算异或（XOR），也称为互斥析取（exclusive disjunction）。异或是当一个输入为1另一个输入为0是，输出结果为1，否则为0。异或的结果如下图所示，当结果为1，样本用圆圈表示，当结果为0，样本用菱形表示：</p>
<p><img src="posts/8-the-perceptron/mlslpic/8.8%20xor.png" alt="xor"></p>
<p>这种情况下，不可能用一条直线将圆圈和菱形分开。假设这四个样本都是定在板上的钉子，你用一条橡皮筋把两个阳性类型的样本连起来，再用另一条橡皮筋把两个阴性类型的样本连起来。这两条橡皮筋称为凸包（convex hull），或者包含一个集合内所有点的外壳，这个集合内任意两点的连线都在这个外壳的内部。相比低维空间，这种特征更可能在高维空间实现线性可分。例如，在使用词袋模型分类文本分类问题时，高维特征向量更容易实现线性可分。</p>
<p>后面两章，我们将介绍处理线性不可分数据集的方法。第一个方法是核心化算法(kernelization)，将线性不可分数据集映射到高维空间变成线性可分数据集。核心化算法可以用在许多场合，包括感知器，但是最适合的场景是支持向量机，我们下一章将会介绍。支持向量机也提供了一些找超平面的技术，以最小的误差分离线性不可分数据集。第一个方法建立了一种感知器有向图，其模型称为人工神经网络，是一种通用函数近似器，我们将在本书的最后一章介绍它。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="总结">总结<a class="anchor-link" href="posts/8-the-perceptron/#%E6%80%BB%E7%BB%93">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>本章，我们介绍了感知器。源自神经元知识，感知器是一个二元分类线性模型。感知器将解释变量和权重的线性组合作为激励函数的输入，通过激励函数的结果预测样本的类型。带逻辑S形激励函数的感知器就和逻辑回归模型一样，只是感知器用一种实时的错误驱动算法计算权重参数。感知器可以有效的解决一下问题。和我们介绍过的其他线性模型一样，感知器并非通用函数近似器；它只能用一个超平面分类两种类型。有一些线性不可分数据集，不存在一个超平面来正确的区分所有样本。在后面的章节，我们将介绍两种处理线性不可分数据集的模型：支持向量机，将线性不可分数据集映射到高维空间变成线性可分数据集；人工神经网络，一种带感知器有向图的通用函数近似器。</p>

</div>
</div>
</div>
    </div>
  </div>

    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/7-dimensionality-reduction-with-pca/" class="u-url">7-dimensionality-reduction-with-pca</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Tao Junjie</span></p>
            <p class="dateline"><a href="posts/7-dimensionality-reduction-with-pca/" rel="bookmark"><time class="published dt-published" datetime="2015-07-02T09:38:42+08:00" itemprop="datePublished" title="Publication date">2015-07-02 09:38</time></a></p>
                <p class="commentline">            <a href="posts/7-dimensionality-reduction-with-pca/#disqus_thread" data-disqus-identifier="cache/posts/7-dimensionality-reduction-with-pca.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div tabindex="-1" id="notebook" class="border-box-sizing">
    <div class="container" id="notebook-container">

<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="用PCA降维">用PCA降维<a class="anchor-link" href="posts/7-dimensionality-reduction-with-pca/#%E7%94%A8PCA%E9%99%8D%E7%BB%B4">¶</a>
</h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>本章我们将介绍一种降维方法，PCA（Principal Component Analysis，主成分分析）。降维致力于解决三类问题。第一，降维可以缓解维度灾难问题。第二，降维可以在压缩数据的同时让信息损失最小化。第三，理解几百个维度的数据结构很困难，两三个维度的数据通过可视化更容易理解。下面，我们用PCA将一个高维数据降成二维，方便可视化，之后，我们建一个脸部识别系统。</p>
<!-- TEASER_END-->
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="PCA简介">PCA简介<a class="anchor-link" href="posts/7-dimensionality-reduction-with-pca/#PCA%E7%AE%80%E4%BB%8B">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>在<em>第三章，特征提取与处理</em>里面，涉及高维特征向量的问题往往容易陷入维度灾难。随着数据集维度的增加，算法学习需要的样本数量呈指数级增加。有些应用中，遇到这样的大数据是非常不利的，而且从大数据集中学习需要更多的内存和处理能力。另外，随着维度的增加，数据的稀疏性会越来越高。在高维向量空间中探索同样的数据集比在同样稀疏的数据集中探索更加困难。</p>
<p>主成分分析也称为卡尔胡宁-勒夫变换（Karhunen-Loeve Transform），是一种用于探索高维数据结构的技术。PCA通常用于高维数据集的探索与可视化。还可以用于数据压缩，数据预处理等。PCA可以把可能具有相关性的高维变量合成线性无关的低维变量，称为主成分（ principal components）。新的低维数据集会经可能的保留原始数据的变量。</p>
<p>PCA将数据投射到一个低维子空间实现降维。例如，二维数据集降维就是把点投射成一条线，数据集的每个样本都可以用一个值表示，不需要两个值。三维数据集可以降成二维，就是把变量映射成一个平面。一般情况下，$n$维数据集可以通过映射降成$k$维子空间，其中$k<n><p>假如你是一本养花工具宣传册的摄影师，你正在拍摄一个水壶。水壶是三维的，但是照片是二维的，为了更全面的把水壶展示给客户，你需要从不同角度拍几张图片。下图是你从四个方向拍的照片：</p>
<p><img src="posts/7-dimensionality-reduction-with-pca/mlslpic/7.1%20wateringcan.png" alt="wateringcan"></p>
<p>第一张图里水壶的背面可以看到，但是看不到前面。第二张图是拍前面，可以看到壶嘴，这张图可以提供了第一张图缺失的信息，但是壶把看不到了。从第三张俯视图里无法看出壶的高度。第四张图是你打算放进目录的，水壶的高度，顶部，壶嘴和壶把都清晰可见。</p>
<p>PCA的设计理念与此类似，它可以将高维数据集映射到低维空间的同时，尽可能的保留更多变量。PCA旋转数据集与其主成分对齐，将最多的变量保留到第一主成分中。假设我们有下图所示的数据集：</p>
<p><img src="posts/7-dimensionality-reduction-with-pca/mlslpic/7.2%20dataset.png" alt="dataset"></p>
<p>数据集看起来像一个从原点到右上角延伸的细长扁平的椭圆。要降低整个数据集的维度，我们必须把点映射成一条线。下图中的两条线都是数据集可以映射的，映射到哪条线样本变化最大？</p>
<p><img src="posts/7-dimensionality-reduction-with-pca/mlslpic/7.3%20datasetline.png" alt="datasetline"></p>
<p>显然，样本映射到虚线的变化比映射到点线的变化。实际上，这条虚线就是第一主成分。第二主成分必须与第一主成分正交，也就是说第二主成分必须是在统计学上独立的，会出现在与第一主成分垂直的方向，如下图所示：</p>
<p><img src="posts/7-dimensionality-reduction-with-pca/mlslpic/7.4%20orthogonal.png" alt="orthogonal"></p>
<p>后面的每个主成分也会尽量多的保留剩下的变量，唯一的要求就是每一个主成分需要和前面的主成分正交。</p>
<p>现在假设数据集是三维的，散点图看起来像是沿着一个轴旋转的光盘。</p>
<p><img src="posts/7-dimensionality-reduction-with-pca/mlslpic/7.5%20threedimensional.png" alt="threedimensional"></p>
<p>这些点可以通过旋转和变换使光盘完全变成二维的。现在这些点看着像一个椭圆，第三维上基本没有变量，可以被忽略。</p>
<p>当数据集不同维度上的方差分布不均匀的时候，PCA最有用。如果是一个球壳行数据集，PCA不能有效的发挥作用，因为各个方向上的方差都相等；没有丢失大量的信息维度一个都不能忽略。</p>

</n></p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="PCA计算步骤">PCA计算步骤<a class="anchor-link" href="posts/7-dimensionality-reduction-with-pca/#PCA%E8%AE%A1%E7%AE%97%E6%AD%A5%E9%AA%A4">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>在介绍PCA的运行步骤之前，有一些术语需要说明一下。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="方差，协方差和协方差矩阵">方差，协方差和协方差矩阵<a class="anchor-link" href="posts/7-dimensionality-reduction-with-pca/#%E6%96%B9%E5%B7%AE%EF%BC%8C%E5%8D%8F%E6%96%B9%E5%B7%AE%E5%92%8C%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5">¶</a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>方差（Variance）是度量一组数据分散的程度。方差是各个样本与样本均值的差的平方和的均值：</p>
$$s^2 = \frac {\sum_{i=1}^n {{(X_i-\bar X)}^2}} {n-1}$$<p>协方差（Covariance）是度量两个变量的变动的同步程度，也就是度量两个变量线性相关性程度。如果两个变量的协方差为0，则统计学上认为二者线性无关。注意两个无关的变量并非完全独立，只是没有线性相关性而已。计算公式如下：</p>
$$cov(X,Y)=\frac {\sum_{i=1}^n {(X_i-\bar X)(X_i-\bar Y)}} {n-1}$$<p>如果协方差不为0，如果大于0表示正相关，小于0表示负相关。当协方差大于0时，一个变量增大是另一个变量也会增大。当协方差小于0时，一个变量增大是另一个变量会减小。协方差矩阵（Covariance matrix）由数据集中两两变量的协方差组成。矩阵的第$(i,j)$个元素是数据集中第$i$和第$j$个元素的协方差。例如，三维数据的协方差矩阵如下所示：</p>
$$
C=
\begin{bmatrix}
cov(x_1,x_1) &amp; cov(x_1,x_2) &amp; cov(x_1,x_3)\\
cov(x_2,x_1) &amp; cov(x_2,x_2) &amp; cov(x_2,x_3)\\
cov(x_3,x_1) &amp; cov(x_3,x_2) &amp; cov(x_3,x_3)\\
\end{bmatrix}
$$<p>让我们计算下表数据的协方差矩阵：</p>
<table>
<thead><tr>
<th style="text-align:center">X1</th>
<th style="text-align:center">X2</th>
<th style="text-align:center">X3</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">−1.4</td>
</tr>
<tr>
<td style="text-align:center">2.2</td>
<td style="text-align:center">0.2</td>
<td style="text-align:center">−1.5</td>
</tr>
<tr>
<td style="text-align:center">2.4</td>
<td style="text-align:center">0.1</td>
<td style="text-align:center">−1</td>
</tr>
<tr>
<td style="text-align:center">1.9</td>
<td style="text-align:center">0</td>
<td style="text-align:center">−1.2</td>
</tr>
</tbody>
</table>
<p>三个变量的样本均值分别是2.125，0.075和-1.275。用Numpy计算协方差矩阵如下：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.4</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">2.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">2.4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">1.9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.2</span><span class="p">]]</span>
<span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>[[ 0.04916667  0.01416667  0.01916667]
 [ 0.01416667  0.00916667 -0.00583333]
 [ 0.01916667 -0.00583333  0.04916667]]
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="特征向量和特征值">特征向量和特征值<a class="anchor-link" href="posts/7-dimensionality-reduction-with-pca/#%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F%E5%92%8C%E7%89%B9%E5%BE%81%E5%80%BC">¶</a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>向量是具有大小（magnitude）和方向（direction）的几何概念。特征向量（eigenvector）是一个矩阵的满足如下公式的非零向量：</p>
$$A \vec \nu = \lambda \vec \nu$$<p>其中，$\vec \nu$是特征向量，$A$是方阵，$\lambda$是特征值。经过$A$变换之后，特征向量的方向保持不变，只是其大小发生了特征值倍数的变化。也就是说，一个特征向量左乘一个矩阵之后等于等比例放缩（scaling）特征向量。德语单词<em>eigen</em>的意思是<em>属于...或...专有（ belonging to or peculiar to）</em>；矩阵的特征向量是属于并描述数据集结构的向量。</p>
<p>特征向量和特征值只能由方阵得出，且并非所有方阵都有特征向量和特征值。如果一个矩阵有特征向量和特征值，那么它的每个维度都有一对特征向量和特征值。矩阵的主成分是其协方差矩阵的特征向量，按照对应的特征值大小排序。最大的特征值就是第一主成分，第二大的特征值就是第二主成分，以此类推。</p>
<p>让我们来计算下面矩阵的特征向量和特征值：</p>
$$A=
\begin{bmatrix}
1 &amp; -2 \\
2 &amp; -3 \\
\end{bmatrix}
$$<p>根据前面的公式$A$乘以特征向量，必然等于特征值乘以特征向量。我们建立特征方程求解：</p>
$$(A- \lambda I) \vec \nu=0$$$$|A-\lambda * I| = 
\begin{vmatrix}
\begin{bmatrix}
1 &amp; -2 \\
2 &amp; -3 \\
\end{bmatrix}
-
\begin{bmatrix}
\lambda &amp; 0 \\
0 &amp; \lambda \\
\end{bmatrix}
\end{vmatrix}
= 0
$$<p>从特征方程可以看出，矩阵与单位矩阵和特征值乘积的矩阵行列式为0：</p>
$$
\begin{vmatrix}
\begin{bmatrix}
1-\lambda &amp; -2 \\
2 &amp; -3-\lambda \\
\end{bmatrix}
\end{vmatrix}
=(\lambda+1)(\lambda+1)
= 0
$$<p>矩阵的两个特征值都等于-1。现在再用特征值来解特征向量。</p>
$$A \vec \nu = \lambda \vec \nu$$<p>首先，我们用特征方程：</p>
$$(A- \lambda I) \vec \nu=0$$<p>把数据带入：</p>
$$
\begin{pmatrix}
\begin{bmatrix}
1 &amp; -2 \\
2 &amp; -3 \\
\end{bmatrix}
-
\begin{bmatrix}
\lambda &amp; 0 \\
0 &amp; \lambda \\
\end{bmatrix}
\end{pmatrix}
\vec \nu
=
\begin{bmatrix}
1-\lambda &amp; -2 \\
2 &amp; -3-\lambda \\
\end{bmatrix}
\vec \nu
=
\begin{bmatrix}
1-\lambda &amp; -2 \\
2 &amp; -3-\lambda \\
\end{bmatrix}
\begin{bmatrix}
\nu_{1,1} \\
\nu_{1,2} \\
\end{bmatrix}
=0
$$
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>我们把特征值代入方程：</p>
$$\begin{bmatrix}
1-(-1) &amp; -2 \\
2 &amp; -3-(-1) \\
\end{bmatrix}
\begin{bmatrix}
\nu_{1,1} \\
\nu_{1,2} \\
\end{bmatrix}
=
\begin{bmatrix}
2 &amp; -2 \\
2 &amp; -2 \\
\end{bmatrix}
\begin{bmatrix}
\nu_{1,1} \\
\nu_{1,2} \\
\end{bmatrix}
=0
$$<p>可以重新整理成如下方程：</p>
<p>\begin{Bmatrix}
2\nu<em>{1,1} + -(2\nu</em>{1,2})=0 \
2\nu<em>{1,1} + -(2\nu</em>{1,2})=0 \
\end{Bmatrix}</p>
<p>任何满足方程的非零向量都可以作为特征向量：
$$
\begin{bmatrix}
1 &amp; -2 \
2 &amp; -3 \
\end{bmatrix}
\begin{bmatrix}
1 \
1 \</p>
<h2 id="\end{bmatrix}">\end{bmatrix}<a class="anchor-link" href="posts/7-dimensionality-reduction-with-pca/#%5Cend%7Bbmatrix%7D">¶</a>
</h2>\begin{bmatrix}
1 \\
1 \\
\end{bmatrix}<p>=
\begin{bmatrix}
-1 \
-1 \
\end{bmatrix}
$$</p>
<p>PCA需要单位特征向量，也就是L2范数等于1的特征向量：</p>
$$
\begin{Vmatrix}
x \\
\end{Vmatrix}
=
\sqrt {x_1^2 + x_2^2 + \dots + x_n^2}
$$<p>那么把前面的特征向量带入可得：</p>
$$
\begin{Vmatrix}
\begin{bmatrix}
1 \\
1 \\
\end{bmatrix}
\end{Vmatrix}
=
\sqrt {1^2+1^2}
=
\sqrt 2
$$<p>于是单位特征向量是：</p>
$$
\begin{bmatrix}
1 \\
1 \\
\end{bmatrix} / {\sqrt 2}
=
\begin{bmatrix}
0.70710678 \\
0.70710678 \\
\end{bmatrix}
$$<p>我们可以通过Numpy检验我们手算的特征向量。<code>eig</code>函数返回特征值和特征向量的元组：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [8]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">]]))</span>
<span class="k">print</span><span class="p">(</span><span class="s">'特征值：{}</span><span class="se">\n</span><span class="s">特征向量：{}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>特征值：[-0.99999998 -1.00000002]
特征向量：[[ 0.70710678  0.70710678]
 [ 0.70710678  0.70710678]]
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="用PCA降维">用PCA降维<a class="anchor-link" href="posts/7-dimensionality-reduction-with-pca/#%E7%94%A8PCA%E9%99%8D%E7%BB%B4">¶</a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>让我们用PCA方法把下表二维数据降成一维：</p>
<table>
<thead><tr>
<th style="text-align:center">X1</th>
<th style="text-align:center">X2</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align:center">0.9</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2.4</td>
<td style="text-align:center">2.6</td>
</tr>
<tr>
<td style="text-align:center">1.2</td>
<td style="text-align:center">1.7</td>
</tr>
<tr>
<td style="text-align:center">0.5</td>
<td style="text-align:center">0.7</td>
</tr>
<tr>
<td style="text-align:center">0.3</td>
<td style="text-align:center">0.7</td>
</tr>
<tr>
<td style="text-align:center">1.8</td>
<td style="text-align:center">1.4</td>
</tr>
<tr>
<td style="text-align:center">0.5</td>
<td style="text-align:center">0.6</td>
</tr>
<tr>
<td style="text-align:center">0.3</td>
<td style="text-align:center">0.6</td>
</tr>
<tr>
<td style="text-align:center">2.5</td>
<td style="text-align:center">2.6</td>
</tr>
<tr>
<td style="text-align:center">1.3</td>
<td style="text-align:center">1.1</td>
</tr>
</tbody>
</table>
<p>PCA第一步是用解释变量减去样本均值：</p>
<table>
<thead><tr>
<th style="text-align:center">X1</th>
<th style="text-align:center">X2</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align:center">0.9 - 1.17 = -0.27</td>
<td style="text-align:center">1 - 1.3 = -0.3</td>
</tr>
<tr>
<td style="text-align:center">2.4 - 1.17 = 1.23</td>
<td style="text-align:center">2.6 - 1.3 = 1.3</td>
</tr>
<tr>
<td style="text-align:center">1.2 - 1.17 = 0.03</td>
<td style="text-align:center">1.7 - 1.3 = 0.4</td>
</tr>
<tr>
<td style="text-align:center">0.5 - 1.17 = -0.67</td>
<td style="text-align:center">-0.7 - 1.3 = 0.6</td>
</tr>
<tr>
<td style="text-align:center">0.3 - 1.17 = -0.87</td>
<td style="text-align:center">-0.7 - 1.3 = 0.6</td>
</tr>
<tr>
<td style="text-align:center">1.8 - 1.17 = 0.63</td>
<td style="text-align:center">1.4 - 1.3 = 0.1</td>
</tr>
<tr>
<td style="text-align:center">0.5 - 1.17 = -0.67</td>
<td style="text-align:center">0.6 - 1.3 = -0.7</td>
</tr>
<tr>
<td style="text-align:center">0.3 - 1.17 = -0.87</td>
<td style="text-align:center">0.6 - 1.3 = -0.7</td>
</tr>
<tr>
<td style="text-align:center">2.5 - 1.17 = 1.33</td>
<td style="text-align:center">2.6 - 1.3 = 1.3</td>
</tr>
<tr>
<td style="text-align:center">1.3 - 1.17 = 0.13</td>
<td style="text-align:center">1.1 - 1.3 = -0.2</td>
</tr>
</tbody>
</table>
<p>然后，我们计算数据的主成分。前面介绍过，矩阵的主成分是其协方差矩阵的特征向量，按照对应的特征值大小排序。主成分可以通过两种方法计算。第一种方法是计算数据协方差矩阵。因为协方差矩阵是方阵，所有我们可以用前面的方法计算特征值和特征向量。第二种方法是用数据矩阵的奇异值分解（singular value decomposition）来找协方差矩阵的特征向量和特征值的平方根。我们先介绍第一种方法，然后介绍scikit-learn的PCA实现，也就是第二种方法。上述数据集的解释变量协方差矩阵如下：</p>
$$
C=
\begin{bmatrix}
0.6867777778 &amp; 0.6066666667 \\
0.6066666667 &amp; 0.5977777778 \\
\end{bmatrix}
$$<p>用前面介绍过的方法，特征值是1.250和0.034，单位特征向量是：</p>
$$
\begin{bmatrix}
0.73251454 &amp; 0.68075138 \\
0.68075138 &amp; 0.73251454 \\
\end{bmatrix}
$$<p>下面我们把数据映射到主成分上。第一主成分是最大特征值对应的特征向量，因此我们要建一个转换矩阵，它的每一列都是主成分的特征向量。如果我们要把5维数据降成3维，那么我们就要用一个3维矩阵做转换矩阵。在本例中，我们将把我们的二维数据映射成一维，因此我们只需要用特征向量中的第一主成分。最后，我们用数据矩阵点乘转换矩阵。下面就是第一主成分映射的结果：</p>
$$
\begin{bmatrix}
-0.27 &amp; -0.3 \\
1.23 &amp; 1.3 \\
0.03 &amp; 0.4 \\
-0.67 &amp; 0.6 \\
-0.87 &amp; 0.6 \\
0.63 &amp; 0.1 \\
-0.67 &amp; -0.7 \\
-0.87 &amp; -0.7 \\
1.33 &amp; 1.3 \\
0.13 &amp; -0.2 \\
\end{bmatrix}
\begin{bmatrix}
0.73251454 \\
0.68075138 \\
\end{bmatrix}
=
\begin{bmatrix}
-0.40200434 \\
 1.78596968 \\
 0.29427599 \\
-0.08233391 \\
-0.22883682 \\
 0.5295593  \\
-0.96731071 \\
-1.11381362 \\
 1.85922113 \\
-0.04092339 \\
\end{bmatrix}
$$<p>通过Numpy的<code>dot</code>函数计算如下：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [12]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mf">0.27</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">],</span>
<span class="p">[</span><span class="mf">1.23</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">],</span>
<span class="p">[</span><span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.67</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">],</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.87</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">],</span>
<span class="p">[</span><span class="mf">0.63</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.67</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.7</span><span class="p">],</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.87</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.7</span><span class="p">],</span>
<span class="p">[</span><span class="mf">1.33</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">],</span>
<span class="p">[</span><span class="mf">0.13</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">]]</span>

<span class="n">b</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.73251454</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.68075138</span><span class="p">]]</span>

<span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[12]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>array([[-0.40200434],
       [ 1.78596968],
       [ 0.29427599],
       [-0.08233391],
       [-0.22883682],
       [ 0.5295593 ],
       [-0.96731071],
       [-1.11381362],
       [ 1.85922113],
       [-0.04092339]])</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>许多PCA的实现方法，包括scikit-learn的实现方法都是用奇异值分解计算特征值和特征向量。SVD计算公式如下：</p>
$$X=U \sum {V^T}$$<p>列向量$U$称为数据矩阵的左奇异值向量，$V$称为数据矩阵的右奇异值向量，$\sum$的对角线元素是它的奇异值。矩阵的奇异值向量和奇异值在一些信号处理和统计学中是十分有用的，我们只对它们与数据矩阵特征向量和特征值相关的内容感兴趣。具体来说，左奇异值向量就是协方差矩阵的特征向量，$\sum$的对角线元素是协方差矩阵的特征值的平方根。计算SVD超出本书范围，不过用SVD找特征向量的方法与通过协方差矩阵解析方法类似，详细内容见线性代数教程。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="用PCA实现高维数据可视化">用PCA实现高维数据可视化<a class="anchor-link" href="posts/7-dimensionality-reduction-with-pca/#%E7%94%A8PCA%E5%AE%9E%E7%8E%B0%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>二维或三维数据更容易通过可视化发现模式。一个高维数据集是无法用图形表示的，但是我们可以通过降维方法把它降成二维或三维数据来可视化。</p>
<p>Fisher1936年收集了三种鸢尾花分别50个样本数据（Iris Data）：Setosa、Virginica、Versicolour。解释变量是花瓣（petals）和萼片（sepals）长度和宽度的测量值，响应变量是花的种类。鸢尾花数据集经常用于分类模型测试，scikit-learn中也有。让我们把<code>iris</code>数据集降成方便可视化的二维数据：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [5]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span class="o">%</span><span class="k">matplotlib</span> inline
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_iris</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>首先，我们导入鸢尾花数据集和<code>PCA</code>估计器。<code>PCA</code>类把主成分的数量作为超参数，和其他估计器一样，<code>PCA</code>也用<code>fit_transform()</code>返回降维的数据矩阵：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [6]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span class="n">data</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">()</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">target</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span>
<span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">reduced_X</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>最后，我们把图形画出来：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [9]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span class="n">red_x</span><span class="p">,</span> <span class="n">red_y</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
<span class="n">blue_x</span><span class="p">,</span> <span class="n">blue_y</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
<span class="n">green_x</span><span class="p">,</span> <span class="n">green_y</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reduced_X</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">red_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reduced_X</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">red_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reduced_X</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">blue_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reduced_X</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">blue_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reduced_X</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">green_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reduced_X</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">green_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reduced_X</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">red_x</span><span class="p">,</span> <span class="n">red_y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s">'r'</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'x'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">blue_x</span><span class="p">,</span> <span class="n">blue_y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s">'b'</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'D'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">green_x</span><span class="p">,</span> <span class="n">green_y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s">'g'</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>


<div class="output_png output_subarea ">
<img src="data:image/png;base64,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%0AZw7rZAAAAABJRU5ErkJggg==">
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>降维的数据如上图所示。每个数据集中三个类都用不同的符号标记。从这个二维数据图中可以明显看出，有一个类与其他两个重叠的类完全分离。这个结果可以帮助我们选择分类模型。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="PCA脸部识别">PCA脸部识别<a class="anchor-link" href="posts/7-dimensionality-reduction-with-pca/#PCA%E8%84%B8%E9%83%A8%E8%AF%86%E5%88%AB">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>现在让我们用PCA来解决一个脸部识别问题。脸部识别是一个监督分类任务，用于从照片中认出某个人。本例中，我们用剑桥大学AT&amp;T实验室的<a href="http://www.cl.cam.ac.uk/research/dtg/attarchive/facedatabase.html">Our Database of Faces数据集</a>，这个数据集包含40个人每个人10张照片。这些照片是在不同的光照条件下拍摄的，每张照片的表情也不同。照片都是黑白的，尺寸为92 x 112像素。虽然这些图片都不大，但是每张图片的按像素强度排列的特征向量也有10304维。这些高维数据的训练可能需要很多样本才能避免拟合过度。而我们样本量并不大，所有我们用PCA计算一些主成分来表示这些照片。</p>
<p>我们可以把照片的像素强度矩阵转换成向量，然后用所有的训练照片的向量建一个矩阵。每个照片都是数据集主成分的线性组合。在脸部识别理论中，这些主成分称为特征脸（eigenfaces）。特征脸可以看成是脸部的标准化组成部分。数据集中的每张脸都可以通过一些标准脸的组合生成出来，或者说是最重要的特征脸线性组合的近似值。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">walk</span><span class="p">,</span> <span class="n">path</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">mahotas</span> <span class="kn">as</span> <span class="nn">mh</span>
<span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="kn">import</span> <span class="n">cross_val_score</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">scale</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>下面我们把照片导入<code>Numpy</code>数组，然后把它们的像素矩阵转换成向量：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [6]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span class="k">for</span> <span class="n">dir_path</span><span class="p">,</span> <span class="n">dir_names</span><span class="p">,</span> <span class="n">file_names</span> <span class="ow">in</span> <span class="n">walk</span><span class="p">(</span><span class="s">'mlslpic/att-faces/'</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">file_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fn</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="s">'pgm'</span><span class="p">:</span>
            <span class="n">image_filename</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_path</span><span class="p">,</span> <span class="n">fn</span><span class="p">)</span>
            <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scale</span><span class="p">(</span><span class="n">mh</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">image_filename</span><span class="p">,</span> <span class="n">as_grey</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">10304</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">'float32'</span><span class="p">)))</span>
            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dir_path</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>然后，我们用交叉检验建立训练集和测试集，在训练集上用<code>PCA：</code></p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [3]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>我们把所有样本降到150维，然后训练一个逻辑回归分类器。数据集包括40个类；scikit-learn底层会自动用one versus all策略创建二元分类器：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [4]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span class="n">X_train_reduced</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">X_test_reduced</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'训练集数据的原始维度是：{}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">'PCA降维后训练集数据是：{}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">X_train_reduced</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
<span class="n">classifier</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>
<span class="n">accuracies</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="n">X_train_reduced</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>训练集数据的原始维度是：(300, 10304)
PCA降维后训练集数据是：(300, 150)
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>最后，我们用交叉验证和测试集评估分类器的性能。分类器的平均综合评价指标（F1 score）是0.88，但是需要花费更多的时间训练，在更多训练实例的应用中可能会更慢。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [7]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span class="k">print</span><span class="p">(</span><span class="s">'交叉验证准确率是：{}</span><span class="se">\n</span><span class="s">{}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">accuracies</span><span class="p">),</span> <span class="n">accuracies</span><span class="p">))</span>
<span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_reduced</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_reduced</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">predictions</span><span class="p">))</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>交叉验证准确率是：0.823104855161
[ 0.84210526  0.79        0.8372093 ]
             precision    recall  f1-score   support

mlslpic/att-faces/s1       1.00      1.00      1.00         1
mlslpic/att-faces/s10       1.00      1.00      1.00         2
mlslpic/att-faces/s11       1.00      0.83      0.91         6
mlslpic/att-faces/s12       1.00      1.00      1.00         2
mlslpic/att-faces/s13       1.00      1.00      1.00         3
mlslpic/att-faces/s14       0.33      1.00      0.50         2
mlslpic/att-faces/s15       1.00      1.00      1.00         4
mlslpic/att-faces/s17       1.00      1.00      1.00         2
mlslpic/att-faces/s18       1.00      1.00      1.00         2
mlslpic/att-faces/s19       1.00      1.00      1.00         2
mlslpic/att-faces/s2       0.00      0.00      0.00         0
mlslpic/att-faces/s20       1.00      1.00      1.00         2
mlslpic/att-faces/s21       1.00      1.00      1.00         3
mlslpic/att-faces/s22       1.00      1.00      1.00         3
mlslpic/att-faces/s23       1.00      1.00      1.00         1
mlslpic/att-faces/s24       1.00      1.00      1.00         3
mlslpic/att-faces/s25       1.00      1.00      1.00         4
mlslpic/att-faces/s26       1.00      1.00      1.00         4
mlslpic/att-faces/s27       1.00      1.00      1.00         3
mlslpic/att-faces/s28       0.00      0.00      0.00         1
mlslpic/att-faces/s29       1.00      0.50      0.67         2
mlslpic/att-faces/s3       1.00      1.00      1.00         3
mlslpic/att-faces/s30       1.00      1.00      1.00         3
mlslpic/att-faces/s31       0.75      1.00      0.86         3
mlslpic/att-faces/s32       1.00      0.75      0.86         4
mlslpic/att-faces/s33       0.00      0.00      0.00         1
mlslpic/att-faces/s34       0.75      1.00      0.86         3
mlslpic/att-faces/s35       1.00      1.00      1.00         2
mlslpic/att-faces/s36       0.50      1.00      0.67         1
mlslpic/att-faces/s37       1.00      0.17      0.29         6
mlslpic/att-faces/s38       1.00      1.00      1.00         2
mlslpic/att-faces/s39       1.00      1.00      1.00         2
mlslpic/att-faces/s4       1.00      1.00      1.00         1
mlslpic/att-faces/s40       0.00      0.00      0.00         1
mlslpic/att-faces/s5       0.80      0.80      0.80         5
mlslpic/att-faces/s6       1.00      1.00      1.00         2
mlslpic/att-faces/s7       1.00      1.00      1.00         2
mlslpic/att-faces/s8       1.00      1.00      1.00         4
mlslpic/att-faces/s9       1.00      1.00      1.00         3

avg / total       0.93      0.88      0.88       100

</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="总结">总结<a class="anchor-link" href="posts/7-dimensionality-reduction-with-pca/#%E6%80%BB%E7%BB%93">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>本章，我们介绍了降维问题。高维数据不能轻易可视化。估计器训练高维数据集时，也可能出现维度灾难。我们通过主成分分析法缓解这些问题，将可能解释变量具有相关性的高维数据集，通过将数据映射到一个低维子空间，降维成一个线性无关的低维数据集。我们用主成分分析将四维的鸢尾花数据集降成二维数据进行可视化，还建立了一个脸部识别系统。下一章，我们将回到监督学习方法，介绍一种分类算法——感知器（perceptron），本书的最后两章都是建立在感知器的基础上。</p>

</div>
</div>
</div>
    </div>
  </div>

    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/4-from-linear-regression-to-logistic-regression/" class="u-url">4-from-linear-regression-to-logistic-regression</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Tao Junjie</span></p>
            <p class="dateline"><a href="posts/4-from-linear-regression-to-logistic-regression/" rel="bookmark"><time class="published dt-published" datetime="2015-06-29T20:49:07+08:00" itemprop="datePublished" title="Publication date">2015-06-29 20:49</time></a></p>
                <p class="commentline">            <a href="posts/4-from-linear-regression-to-logistic-regression/#disqus_thread" data-disqus-identifier="cache/posts/4-from-linear-regression-to-logistic-regression.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div tabindex="-1" id="notebook" class="border-box-sizing">
    <div class="container" id="notebook-container">

<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="从线性回归到逻辑回归">从线性回归到逻辑回归<a class="anchor-link" href="posts/4-from-linear-regression-to-logistic-regression/#%E4%BB%8E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%88%B0%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92">¶</a>
</h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>在第2章，线性回归里面，我们介绍了一元线性回归，多元线性回归和多项式回归。这些模型都是广义线性回归模型的具体形式，广义线性回归是一种灵活的框架，比普通线性回归要求更少的假设。这一章，我们讨论广义线性回归模型的具体形式的另一种形式，逻辑回归（logistic regression）。</p>
<!-- TEASER_END-->
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>和前面讨论的模型不同，逻辑回归是用来做分类任务的。分类任务的目标是找一个函数，把观测值匹配到相关的类和标签上。学习算法必须用成对的特征向量和对应的标签来估计匹配函数的参数，从而实现更好的分类效果。在二元分类（binary classification）中，分类算法必须把一个实例配置两个类别。二元分类案例包括，预测患者是否患有某种疾病，音频中是否含有人声，杜克大学男子篮球队在NCAA比赛中第一场的输赢。多元分类中，分类算法需要为每个实例都分类一组标签。本章，我们会用逻辑回归来介绍一些分类算法问题，研究分类任务的效果评价，也会用到上一章学的特征抽取方法。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="逻辑回归处理二元分类">逻辑回归处理二元分类<a class="anchor-link" href="posts/4-from-linear-regression-to-logistic-regression/#%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%A4%84%E7%90%86%E4%BA%8C%E5%85%83%E5%88%86%E7%B1%BB">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>普通的线性回归假设响应变量呈正态分布，也称为高斯分布（Gaussian distribution ）或钟形曲线（bell curve）。正态分布数据是对称的，且均值，中位数和众数（mode）是一样的。很多自然现象都服从正态分布。比如，人类的身高就服从正态分布，姚明那样的高度极少，在99%之外了。</p>
<p>在某些问题里，响应变量不是正态分布的。比如，掷一个硬币获取正反两面的概率分布是伯努力分布（Bernoulli distribution），又称两点分布或者0-1分布。表示一个事件发生的概率是$P$，不发生的概率是$1-P$，概率在<code>{0,1}</code>之间。线性回归假设解释变量值的变化会引起响应变量值的变化，如果响应变量的值是概率的，这条假设就不满足了。广义线性回归去掉了这条假设，用一个联连函数(link function)来描述解释变量与响应变量的关系。实际上，在第2章，线性回归里面，我们已经用了联连函数。普通线性回归作为广义线性回归的特例使用的是恒等联连函数(identity link function)，将解释变量的通过线性组合的方式来联接服从正态分布的响应变量。如果响应变量不服从正态分布，就要用另外一种联连函数了。</p>
<p>在逻辑回归里，响应变量描述了类似于掷一个硬币结果为正面的概率。如果响应变量等于或超过了指定的临界值，预测结果就是正面，否则预测结果就是反面。响应变量是一个像线性回归中的解释变量构成的函数表示，称为逻辑函数（logistic function）。一个值在<code>{0,1}</code>之间的逻辑函数如下所示：</p>
$$F(t)=\frac 1 {1+e^{-t}}$$<p>下面是$t$在<code>{-6,6}</code>的图形：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [27]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="o">%</span><span class="k">matplotlib</span> inline
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.font_manager</span> <span class="k">import</span> <span class="n">FontProperties</span>
<span class="n">font</span> <span class="o">=</span> <span class="n">FontProperties</span><span class="p">(</span><span class="n">fname</span><span class="o">=</span><span class="s">r"c:\windows\fonts\msyh.ttc"</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [18]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="k">True</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">X</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s">'b-'</span><span class="p">);</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>


<div class="output_png output_subarea ">
<img src="data:image/png;base64,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">
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>在逻辑回归中，$t$是解释变量的线性组合，公式如下：</p>
$$F(t)=\frac 1 {1+e^{-(\beta_0+\beta_x)}}$$<p>对数函数（logit function）是逻辑函数的逆运算：</p>
$$g(x)=ln {\frac {F(x)} {1-F(x)}} = \beta_0+\beta_x$$<p>定义了逻辑回归的模型之后，我们用它来完成一个分类任务。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="垃圾邮件分类">垃圾邮件分类<a class="anchor-link" href="posts/4-from-linear-regression-to-logistic-regression/#%E5%9E%83%E5%9C%BE%E9%82%AE%E4%BB%B6%E5%88%86%E7%B1%BB">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>经典的二元分类问题就是垃圾邮件分类（spam classification）。这里，我们分类垃圾短信。我们用第三章介绍的TF-IDF算法来抽取短信的特征向量，然后用逻辑回归分类。</p>
<p>我们可以用<a href="http://archive.ics.uci.edu/ml/datasets/SMS+Spam+Collection">UCI Machine Learning Repository</a>的短信垃圾分类数据集（SMS Spam Classification Data Set）。首先，我们还是用Pandas做一些描述性统计：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [21]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'mlslpic/SMSSpamCollection'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s">'</span><span class="se">\t</span><span class="s">'</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="k">None</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'含spam短信数量：'</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">'spam'</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'含ham短信数量：'</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">'ham'</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>      0                                                  1
0   ham  Go until jurong point, crazy.. Available only ...
1   ham                      Ok lar... Joking wif u oni...
2  spam  Free entry in 2 a wkly comp to win FA Cup fina...
3   ham  U dun say so early hor... U c already then say...
4   ham  Nah I don't think he goes to usf, he lives aro...
含spam短信数量： 747
含ham短信数量： 4825
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>每条信息的前面已经被打上了标签。共5574条短信里面，4827条是ham，747条是spam。ham短信用0标记，spam短信用1标记。观察数据会看到更多建模时需要的信息。下面的几条信息体现两种类型的特征：</p>
<ul>
<li>Spam: Free entry in 2 a wkly comp to win FA Cup final tkts 21st May</li>
<li>Text FA to 87121 to receive entry question(std txt rate)T&amp;C's
apply 08452810075over18's</li>
<li>Spam: WINNER!! As a valued network customer you have been selected
to receivea £900 prize reward! To claim call 09061701461. Claim code
KL341. Valid 12 hours only.</li>
<li>Ham: Sorry my roommates took forever, it ok if I come by now?</li>
<li>Ham: Finished class where are you.</li>
</ul>
<p>让我们用<code>LogisticRegression</code>类来预测：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="k">import</span> <span class="n">TfidfVectorizer</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model.logistic</span> <span class="k">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="k">import</span> <span class="n">train_test_split</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>首先，用pandas加载数据<code>.csv</code>文件，然后用<code>train_test_split</code>分成训练集（75%）和测试集（25%）：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [36]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'mlslpic/SMSSpamCollection'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s">'</span><span class="se">\t</span><span class="s">'</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="k">None</span><span class="p">)</span>
<span class="n">X_train_raw</span><span class="p">,</span> <span class="n">X_test_raw</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
<span class="n">df</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>然后，我们建一个<code>TfidfVectorizer</code>实例来计算TF-IDF权重：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [3]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">vectorizer</span> <span class="o">=</span> <span class="n">TfidfVectorizer</span><span class="p">()</span>
<span class="n">X_train</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train_raw</span><span class="p">)</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test_raw</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>最后，我们建一个<code>LogisticRegression</code>实例来训练模型。和<code>LinearRegression</code>类似，<code>LogisticRegression</code>同样实现了<code>fit()</code>和<code>predict()</code>方法。最后把结果打印出来看看：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [5]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">classifier</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>
<span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [25]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">prediction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">predictions</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">'预测类型：%s. 信息：%s'</span> <span class="o">%</span> <span class="p">(</span><span class="n">prediction</span><span class="p">,</span> <span class="n">X_test_raw</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>预测类型：ham. 信息：Are u coming to the funeral home
预测类型：ham. 信息：Love isn't a decision, it's a feeling. If we could decide who to love, then, life would be much simpler, but then less magical
预测类型：ham. 信息：Dont think so. It turns off like randomlly within 5min of opening
预测类型：spam. 信息：Hey happy birthday...
预测类型：ham. 信息：None of that's happening til you get here though
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>分类模型的运行效果如何？有线性回归的度量方法在这里不太适用了。我们感兴趣的是分类是否正确（如第一章介绍的肿瘤预测问题），并不在乎它的决策范围。下面，我们来介绍二元分类的效果评估方法。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="二元分类效果评估方法">二元分类效果评估方法<a class="anchor-link" href="posts/4-from-linear-regression-to-logistic-regression/#%E4%BA%8C%E5%85%83%E5%88%86%E7%B1%BB%E6%95%88%E6%9E%9C%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>二元分类的效果评估方法有很多，常见的包括第一章里介绍的肿瘤预测使用的准确率（accuracy），精确率（precision）和召回率（recall）三项指标，以及综合评价指标（F1 measure）， ROC AUC值（Receiver Operating Characteristic ROC，Area Under Curve，AUC）。这些指标评价的样本分类是真阳性（true positives），真阴性（true negatives），假阳性（false positives），假阴性（false negatives）。阳性和阴性指分类，真和假指预测的正确与否。</p>
<p>在我们的垃圾短信分类里，真阳性是指分类器将一个垃圾短信分辨为spam类。真阴性是指分类器将一个正常短信分辨为ham类。假阳性是指分类器将一个正常短信分辨为spam类。假阴性是指分类器将一个垃圾短信分辨为ham类。混淆矩阵（Confusion matrix），也称列联表分析（Contingency table）可以用来描述真假与阴阳的关系。矩阵的行表示实际类型，列表示预测类型。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [30]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">confusion_matrix</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">y_test</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">confusion_matrix</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'混淆矩阵'</span><span class="p">,</span><span class="n">fontproperties</span><span class="o">=</span><span class="n">font</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'实际类型'</span><span class="p">,</span><span class="n">fontproperties</span><span class="o">=</span><span class="n">font</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'预测类型'</span><span class="p">,</span><span class="n">fontproperties</span><span class="o">=</span><span class="n">font</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>[[4 1]
 [2 3]]
</pre>
</div>
</div>

<div class="output_area">
<div class="prompt"></div>


<div class="output_png output_subarea ">
<img src="data:image/png;base64,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">
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="准确率">准确率<a class="anchor-link" href="posts/4-from-linear-regression-to-logistic-regression/#%E5%87%86%E7%A1%AE%E7%8E%87">¶</a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>准确率是分类器预测正确性的评估指标。scikit-learn提供了<code>accuracy_score</code>来计算：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [31]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">accuracy_score</span>
<span class="n">y_pred</span><span class="p">,</span> <span class="n">y_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>0.5
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><code>LogisticRegression.score()</code>用来计算模型预测的准确率：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [34]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="k">import</span> <span class="n">TfidfVectorizer</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model.logistic</span> <span class="k">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="k">import</span> <span class="n">train_test_split</span><span class="p">,</span> <span class="n">cross_val_score</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'mlslpic/sms.csv'</span><span class="p">)</span>
<span class="n">X_train_raw</span><span class="p">,</span> <span class="n">X_test_raw</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s">'message'</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s">'label'</span><span class="p">])</span>
<span class="n">vectorizer</span> <span class="o">=</span> <span class="n">TfidfVectorizer</span><span class="p">()</span>
<span class="n">X_train</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train_raw</span><span class="p">)</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test_raw</span><span class="p">)</span>
<span class="n">classifier</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>
<span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'准确率：'</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scores</span><span class="p">),</span> <span class="n">scores</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>准确率： 0.958373205742 [ 0.96291866  0.95334928  0.95813397  0.96172249  0.95574163]
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>你的结果可能和这些数字不完全相同，毕竟交叉检验的训练集和测试集都是随机抽取的。准确率是分类器预测正确性的比例，但是并不能分辨出假阳性错误和假阴性错误。在有些问题里面，比如第一章的肿瘤预测问题中，假阴性与假阳性要严重得多，其他的问题里可能相反。另外，有时准确率并非一个有效的衡量指标，如果分类的比例在样本中严重失调。比如，分类器预测信用卡交易是否为虚假交易时，假阴性比假阳性更敏感。为了提高客户满意度，信用卡部门更倾向于对合法的交易进行风险检查，往往会忽略虚假交易。因为绝大部分交易都是合法的，这里准确率不是一个有效的衡量指标。经常预测出虚假交易的分类器可能有很高的准确率，但是实际情况可能并非如此。因此，分类器的预测效果还需要另外两个指标：精确率和召回率。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="精确率和召回率">精确率和召回率<a class="anchor-link" href="posts/4-from-linear-regression-to-logistic-regression/#%E7%B2%BE%E7%A1%AE%E7%8E%87%E5%92%8C%E5%8F%AC%E5%9B%9E%E7%8E%87">¶</a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>第一章的肿瘤预测问题中精确率和召回率的定义我们已经介绍过。在本章的垃圾短信分类器中，精确率是指分类器预测出的垃圾短信中真的是垃圾短信的比例：</p>
$$P = \frac {TP} {TP+FP}$$<p>召回率在医学领域也叫做灵敏度（sensitivity），在本例中是指所有真的垃圾短信被分类器正确找出来的比例。</p>
$$R = \frac {TP} {TP+FN}$$<p>精确率和召回率各自含有的信息都很少，它们对分类器效果的观察角度不同。精确率和召回率都不能从表现差的一种分类器中区分出好的分类器。例如，假设一个测试集包括10个阳性和0个阴性结果。分类器即使将每一个样本都预测为阳性，其召回率都是1：</p>
$$R = \frac {10} {10+0}=1$$<p>分类器如果将每一个样本都预测为阴性，或者只是预测出假阳性和真阴性，其召回率都是0。类似的，一个分类器如果只预测一个样本，结果为阳性，而且这个样本确实为阳性，那么这个分类器就是100%精确的了。</p>
<p>scikit-learn结合真实类型数据，提供了一个函数来计算一组预测值的精确率和召回率。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [38]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="k">import</span> <span class="n">TfidfVectorizer</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model.logistic</span> <span class="k">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="k">import</span> <span class="n">train_test_split</span><span class="p">,</span> <span class="n">cross_val_score</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'mlslpic/sms.csv'</span><span class="p">)</span>
<span class="n">X_train_raw</span><span class="p">,</span> <span class="n">X_test_raw</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s">'message'</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s">'label'</span><span class="p">])</span>
<span class="n">vectorizer</span> <span class="o">=</span> <span class="n">TfidfVectorizer</span><span class="p">()</span>
<span class="n">X_train</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train_raw</span><span class="p">)</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test_raw</span><span class="p">)</span>
<span class="n">classifier</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>
<span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">precisions</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s">'precision'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'精确率：'</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">precisions</span><span class="p">),</span> <span class="n">precisions</span><span class="p">)</span>
<span class="n">recalls</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s">'recall'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'召回率：'</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">recalls</span><span class="p">),</span> <span class="n">recalls</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>精确率： 0.99217372134 [ 0.9875      0.98571429  1.          1.          0.98765432]
召回率： 0.672121212121 [ 0.71171171  0.62162162  0.66363636  0.63636364  0.72727273]
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>我们的分类器精确率99.2%，分类器预测出的垃圾短信中99.2%都是真的垃圾短信。召回率比较低67.2%，就是说真实的垃圾短信中，32.8%被当作正常短信了，没有被识别出来。这些数据会不断变化，因为训练集和测试集是随机抽取的。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="计算综合评价指标">计算综合评价指标<a class="anchor-link" href="posts/4-from-linear-regression-to-logistic-regression/#%E8%AE%A1%E7%AE%97%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>综合评价指标（F1 measure）是精确率和召回率的调和均值（harmonic mean），或加权平均值，也称为F-measure或fF-score。</p>
$$\frac 1 {F1} + \frac 1 {F1} = \frac 1 P + \frac 1 R $$<p>即</p>
$$F1 = 2{\frac {PR} {P+R}}$$<p>综合评价指标平衡了精确率和召回率。一个二元分类模型，精确率和召回率为1，那么综合评价指标为1。如果精确率或召回率为0，那么综合评价指标为0。scikit-learn也提供了计算综合评价指标的函数。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [39]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">f1s</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s">'f1'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'综合评价指标：'</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">f1s</span><span class="p">),</span> <span class="n">f1s</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>综合评价指标： 0.800588878125 [ 0.82722513  0.76243094  0.79781421  0.77777778  0.83769634]
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>本例的综合评价指标是80%。由于精确率和召回率的差异比较小，所以综合评价指标的罚值也比较小。有时也会用F0.5和F2，表示精确率权重大于召回率，或召回率权重大于精确率。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="ROC-AUC">ROC AUC<a class="anchor-link" href="posts/4-from-linear-regression-to-logistic-regression/#ROC-AUC">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>ROC曲线（Receiver Operating Characteristic，ROC curve）可以用来可视化分类器的效果。和准确率不同，ROC曲线对分类比例不平衡的数据集不敏感，ROC曲线显示的是对超过限定阈值的所有预测结果的分类器效果。ROC曲线画的是分类器的召回率与误警率（fall-out）的曲线。误警率也称假阳性率，是所有阴性样本中分类器识别为阳性的样本所占比例：</p>
$$F = \frac {FP} {TN+FP}$$<p>AUC是ROC曲线下方的面积，它把ROC曲线变成一个值，表示分类器随机预测的效果。scikit-learn提供了计算ROC和AUC指标的函数</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [40]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="k">import</span> <span class="n">TfidfVectorizer</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model.logistic</span> <span class="k">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="k">import</span> <span class="n">train_test_split</span><span class="p">,</span> <span class="n">cross_val_score</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">roc_curve</span><span class="p">,</span> <span class="n">auc</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'mlslpic/sms.csv'</span><span class="p">)</span>
<span class="n">X_train_raw</span><span class="p">,</span> <span class="n">X_test_raw</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s">'message'</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s">'label'</span><span class="p">])</span>
<span class="n">vectorizer</span> <span class="o">=</span> <span class="n">TfidfVectorizer</span><span class="p">()</span>
<span class="n">X_train</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train_raw</span><span class="p">)</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test_raw</span><span class="p">)</span>
<span class="n">classifier</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>
<span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">classifier</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="n">false_positive_rate</span><span class="p">,</span> <span class="n">recall</span><span class="p">,</span> <span class="n">thresholds</span> <span class="o">=</span> <span class="n">roc_curve</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">predictions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">roc_auc</span> <span class="o">=</span> <span class="n">auc</span><span class="p">(</span><span class="n">false_positive_rate</span><span class="p">,</span> <span class="n">recall</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Receiver Operating Characteristic'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">false_positive_rate</span><span class="p">,</span> <span class="n">recall</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'AUC = %0.2f'</span> <span class="o">%</span> <span class="n">roc_auc</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s">'lower right'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s">'r--'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Recall'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Fall-out'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>


<div class="output_png output_subarea ">
<img src="data:image/png;base64,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%0ARK5CYII=">
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="网格搜索">网格搜索<a class="anchor-link" href="posts/4-from-linear-regression-to-logistic-regression/#%E7%BD%91%E6%A0%BC%E6%90%9C%E7%B4%A2">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>在第二章我们曾经提到过超参数，是需要手动调节的参数，模型无法学习。比如，在我们的垃圾短信分类模型中，超参数出现在TF-IDF中，用来移除太频繁和太稀缺单词的频率阈值，目前函数正则化的权重值。在scikit-learn里面，超参数是在模型建立时设置的。在前面的例子中，我们没有为<code>LogisticRegression()</code>设置参数，是因为用的都是默认值。但是有时候默认值不一定是最优的。网格搜索（Grid search）就是用来确定最优超参数的方法。其原理就是选取可能的参数不断运行模型获取最佳效果。网格搜索用的是穷举法，其缺点在于即使每个超参数的取值范围都很小，计算量也是巨大的。不过这是一个并行问题，参数与参数彼此独立，计算过程不需要同步，所有很多方法都可以解决这个问题。scikit-learn有<code>GridSearchCV()</code>函数解决这个问题：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [5]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="k">import</span> <span class="n">TfidfVectorizer</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model.logistic</span> <span class="k">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.grid_search</span> <span class="k">import</span> <span class="n">GridSearchCV</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="k">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="k">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">precision_score</span><span class="p">,</span> <span class="n">recall_score</span><span class="p">,</span> <span class="n">accuracy_score</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">([</span>
    <span class="p">(</span><span class="s">'vect'</span><span class="p">,</span> <span class="n">TfidfVectorizer</span><span class="p">(</span><span class="n">stop_words</span><span class="o">=</span><span class="s">'english'</span><span class="p">)),</span>
    <span class="p">(</span><span class="s">'clf'</span><span class="p">,</span> <span class="n">LogisticRegression</span><span class="p">())</span>
<span class="p">])</span>
<span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'vect__max_df'</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">),</span>
    <span class="s">'vect__stop_words'</span><span class="p">:</span> <span class="p">(</span><span class="s">'english'</span><span class="p">,</span> <span class="k">None</span><span class="p">),</span>
    <span class="s">'vect__max_features'</span><span class="p">:</span> <span class="p">(</span><span class="mi">2500</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="k">None</span><span class="p">),</span>
    <span class="s">'vect__ngram_range'</span><span class="p">:</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
    <span class="s">'vect__use_idf'</span><span class="p">:</span> <span class="p">(</span><span class="k">True</span><span class="p">,</span> <span class="k">False</span><span class="p">),</span>
    <span class="s">'vect__norm'</span><span class="p">:</span> <span class="p">(</span><span class="s">'l1'</span><span class="p">,</span> <span class="s">'l2'</span><span class="p">),</span>
    <span class="s">'clf__penalty'</span><span class="p">:</span> <span class="p">(</span><span class="s">'l1'</span><span class="p">,</span> <span class="s">'l2'</span><span class="p">),</span>
    <span class="s">'clf__C'</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
<span class="p">}</span>
<span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s">'accuracy'</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'mlslpic/sms.csv'</span><span class="p">)</span>
<span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'message'</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s">'label'</span><span class="p">]</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'最佳效果：%0.3f'</span> <span class="o">%</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_score_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'最优参数组合：'</span><span class="p">)</span>
<span class="n">best_parameters</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_estimator_</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
<span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">'</span><span class="se">\t</span><span class="s">%s: %r'</span> <span class="o">%</span> <span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">best_parameters</span><span class="p">[</span><span class="n">param_name</span><span class="p">]))</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'准确率：'</span><span class="p">,</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">predictions</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'精确率：'</span><span class="p">,</span> <span class="n">precision_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">predictions</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'召回率：'</span><span class="p">,</span> <span class="n">recall_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">predictions</span><span class="p">))</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stderr output_text">
<pre>[Parallel(n_jobs=-1)]: Done   1 jobs       | elapsed:    1.8s
[Parallel(n_jobs=-1)]: Done  50 jobs       | elapsed:   10.1s
[Parallel(n_jobs=-1)]: Done 200 jobs       | elapsed:   27.4s
[Parallel(n_jobs=-1)]: Done 450 jobs       | elapsed:   54.2s
[Parallel(n_jobs=-1)]: Done 800 jobs       | elapsed:  1.6min
[Parallel(n_jobs=-1)]: Done 1250 jobs       | elapsed:  2.4min
[Parallel(n_jobs=-1)]: Done 1800 jobs       | elapsed:  3.4min
[Parallel(n_jobs=-1)]: Done 2450 jobs       | elapsed:  4.6min
[Parallel(n_jobs=-1)]: Done 3200 jobs       | elapsed:  6.0min
[Parallel(n_jobs=-1)]: Done 4050 jobs       | elapsed: 10.6min
[Parallel(n_jobs=-1)]: Done 4608 out of 4608 | elapsed: 11.7min finished
</pre>
</div>
</div>

<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>Fitting 3 folds for each of 1536 candidates, totalling 4608 fits
最佳效果：0.982
最优参数组合：
	clf__C: 10
	clf__penalty: 'l2'
	vect__max_df: 0.25
	vect__max_features: 2500
	vect__ngram_range: (1, 2)
	vect__norm: 'l2'
	vect__stop_words: None
	vect__use_idf: True
准确率： 0.989956958393
精确率： 0.994252873563
召回率： 0.930107526882
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><code>GridSearchCV()</code>函数的参数有待评估模型<code>pipeline</code>，超参数词典<code>parameters</code>和效果评价指标<code>scoring</code>。<code>n_jobs</code>是指并发进程最大数量，设置为<code>-1</code>表示使用所有CPU核心进程。在Python3.4中，可以写一个Python的脚本，让<code>fit()</code>函数可以在<code>main()</code>函数里调用，也可以在Python自带命令行,IPython命令行和IPython Notebook运行。经过网格计算后的超参数在训练集中取得了很好的效果。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="多类分类">多类分类<a class="anchor-link" href="posts/4-from-linear-regression-to-logistic-regression/#%E5%A4%9A%E7%B1%BB%E5%88%86%E7%B1%BB">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>现实中有很多问题不只是分成两类，许多问题都需要分成多个类，成为多类分类问题（Multi-class classification）。比如听到一首歌的样曲之后，可以将其归入某一种音乐风格。这类风格就有许多种。scikit-learn用one-vs.-all或one-vs.-the-rest方法实现多类分类，就是把多类中的每个类都作为二元分类处理。分类器预测样本不同类型，将具有最大置信水平的类型作为样本类型。<code>LogisticRegression()</code>通过one-vs.-all策略支持多类分类。下面，我们用它来分析一个多类分类问题。</p>
<p>假设你想看电影，而你又非常讨厌看太次的电影。所以有品位的你可以在看每部电影之前都会看一堆影评，不过你更讨厌看影评。那么下面我们就用好影评来给电影分类。</p>
<p>本例中，我们利用烂番茄（Rotten Tomatoes）网站影评短语数据对电影进行评价。每个影评可以归入下面5个类项：不给力（negative），不太给力（somewhat negative），中等（neutral），有点给力（somewhat positive）, 给力（positive）。解释变量不会总是直白的语言，因为影评内容千差万别，有讽刺的，否定的，以及其他语义的表述，语义并不直白，这些都会让分类充满挑战。数据集可以从<a href="https://www.kaggle.com/c/sentiment-analysis-on-movie-reviews">kaggle</a>上下载。首先，我们还是用Pandas简单探索一下：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [28]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">import</span> <span class="nn">zipfile</span>
<span class="c"># 压缩节省空间</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZipFile</span><span class="p">(</span><span class="s">'mlslpic/train.zip'</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">namelist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s">'</span><span class="se">\t</span><span class="s">'</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [30]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[30]:</div>

<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<table border="1" class="dataframe">
<thead><tr style="text-align: right;">
<th></th>
      <th>PhraseId</th>
      <th>SentenceId</th>
      <th>Phrase</th>
      <th>Sentiment</th>
    </tr></thead>
<tbody>
<tr>
<th>0</th>
      <td>1</td>
      <td>1</td>
      <td>A series of escapades demonstrating the adage ...</td>
      <td>1</td>
    </tr>
<tr>
<th>1</th>
      <td>2</td>
      <td>1</td>
      <td>A series of escapades demonstrating the adage ...</td>
      <td>2</td>
    </tr>
<tr>
<th>2</th>
      <td>3</td>
      <td>1</td>
      <td>A series</td>
      <td>2</td>
    </tr>
<tr>
<th>3</th>
      <td>4</td>
      <td>1</td>
      <td>A</td>
      <td>2</td>
    </tr>
<tr>
<th>4</th>
      <td>5</td>
      <td>1</td>
      <td>series</td>
      <td>2</td>
    </tr>
</tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [31]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">df</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[31]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>PhraseId      156060
SentenceId    156060
Phrase        156060
Sentiment     156060
dtype: int64</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><code>Sentiment</code>是响应变量，<code>0</code>是不给力（negative），<code>4</code>是给力（positive），其他以此类推。<code>Phrase</code>列是影评的内容。影评中每句话都被分割成一行。我们不需要考虑<code>PhraseId</code>列和<code>SentenceId</code>列。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [32]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">df</span><span class="o">.</span><span class="n">Phrase</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[32]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>0    A series of escapades demonstrating the adage ...
1    A series of escapades demonstrating the adage ...
2                                             A series
3                                                    A
4                                               series
5    of escapades demonstrating the adage that what...
6                                                   of
7    escapades demonstrating the adage that what is...
8                                            escapades
9    demonstrating the adage that what is good for ...
Name: Phrase, dtype: object</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [33]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">df</span><span class="o">.</span><span class="n">Sentiment</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[33]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>count    156060.000000
mean          2.063578
std           0.893832
min           0.000000
25%           2.000000
50%           2.000000
75%           3.000000
max           4.000000
Name: Sentiment, dtype: float64</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [34]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">df</span><span class="o">.</span><span class="n">Sentiment</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[34]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>2    79582
3    32927
1    27273
4     9206
0     7072
dtype: int64</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [35]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">df</span><span class="o">.</span><span class="n">Sentiment</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span><span class="o">/</span><span class="n">df</span><span class="o">.</span><span class="n">Sentiment</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt output_prompt">Out[35]:</div>


<div class="output_text output_subarea output_execute_result">
<pre>2    0.509945
3    0.210989
1    0.174760
4    0.058990
0    0.045316
dtype: float64</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>可以看出，近51%都是评价为<code>2</code>中等（neutral）的电影。可见，在这个问题里，准确率不是一个有信息量的评价指标，因为即使很烂的分类器预测出中等水平的结果，其准确率也是51%。<code>3</code>有点给力（somewhat positive）的电影占21%, <code>4</code>给力（positive）的电影占6%，共占27%。剩下的21%就是不给力（negative），不太给力（somewhat negative）的电影。用scikit-learn来训练分类器：</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [37]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="k">import</span> <span class="n">TfidfVectorizer</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model.logistic</span> <span class="k">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="k">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">classification_report</span><span class="p">,</span> <span class="n">accuracy_score</span><span class="p">,</span> <span class="n">confusion_matrix</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="k">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">sklearn.grid_search</span> <span class="k">import</span> <span class="n">GridSearchCV</span>
<span class="kn">import</span> <span class="nn">zipfile</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">([</span>
    <span class="p">(</span><span class="s">'vect'</span><span class="p">,</span> <span class="n">TfidfVectorizer</span><span class="p">(</span><span class="n">stop_words</span><span class="o">=</span><span class="s">'english'</span><span class="p">)),</span>
    <span class="p">(</span><span class="s">'clf'</span><span class="p">,</span> <span class="n">LogisticRegression</span><span class="p">())</span>
<span class="p">])</span>
<span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'vect__max_df'</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
    <span class="s">'vect__ngram_range'</span><span class="p">:</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
    <span class="s">'vect__use_idf'</span><span class="p">:</span> <span class="p">(</span><span class="k">True</span><span class="p">,</span> <span class="k">False</span><span class="p">),</span>
    <span class="s">'clf__C'</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
<span class="p">}</span>

<span class="n">z</span> <span class="o">=</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZipFile</span><span class="p">(</span><span class="s">'mlslpic/train.zip'</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">namelist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s">'</span><span class="se">\t</span><span class="s">'</span><span class="p">)</span>
<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'Phrase'</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s">'Sentiment'</span><span class="p">]</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">train_size</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s">'accuracy'</span><span class="p">)</span>
<span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'最佳效果：%0.3f'</span> <span class="o">%</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_score_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'最优参数组合：'</span><span class="p">)</span>
<span class="n">best_parameters</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_estimator_</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
<span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">'</span><span class="se">\t</span><span class="s">%s: %r'</span> <span class="o">%</span> <span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">best_parameters</span><span class="p">[</span><span class="n">param_name</span><span class="p">]))</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stderr output_text">
<pre>[Parallel(n_jobs=3)]: Done   1 jobs       | elapsed:    4.6s
[Parallel(n_jobs=3)]: Done  50 jobs       | elapsed:  1.8min
[Parallel(n_jobs=3)]: Done  68 out of  72 | elapsed:  3.0min remaining:   10.6s
[Parallel(n_jobs=3)]: Done  72 out of  72 | elapsed:  3.3min finished
</pre>
</div>
</div>

<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>Fitting 3 folds for each of 24 candidates, totalling 72 fits
最佳效果：0.620
最优参数组合：
	clf__C: 10
	vect__max_df: 0.25
	vect__ngram_range: (1, 2)
	vect__use_idf: False
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="多类分类效果评估">多类分类效果评估<a class="anchor-link" href="posts/4-from-linear-regression-to-logistic-regression/#%E5%A4%9A%E7%B1%BB%E5%88%86%E7%B1%BB%E6%95%88%E6%9E%9C%E8%AF%84%E4%BC%B0">¶</a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>二元分类里，混淆矩阵可以用来可视化不同分类错误的数据。每种类型的精确率，召回率和综合评价指标（F1 score）可以计算，所有预测的准确率也可以计算。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [38]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="n">predictions</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'准确率：'</span><span class="p">,</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">predictions</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'混淆矩阵：'</span><span class="p">,</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">predictions</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s">'分类报告：'</span><span class="p">,</span> <span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">predictions</span><span class="p">))</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>准确率： 0.635024990388
混淆矩阵： [[ 1178  1701   616    71     4]
 [  990  5993  6030   563    30]
 [  227  3231 32668  3520   143]
 [   37   401  6642  8089  1305]
 [    7    30   534  2397  1623]]
分类报告：              precision    recall  f1-score   support

          0       0.48      0.33      0.39      3570
          1       0.53      0.44      0.48     13606
          2       0.70      0.82      0.76     39789
          3       0.55      0.49      0.52     16474
          4       0.52      0.35      0.42      4591

avg / total       0.62      0.64      0.62     78030

</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>我们通过网格搜索获得了最佳参数组合，最终的分类器是通过对开始的分类器不断优化得到的。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="多标签分类和问题转换">多标签分类和问题转换<a class="anchor-link" href="posts/4-from-linear-regression-to-logistic-regression/#%E5%A4%9A%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB%E5%92%8C%E9%97%AE%E9%A2%98%E8%BD%AC%E6%8D%A2">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>前面我们讨论了二元分类，多类分类，还有一种分类问题是多标签分类（multi-label classification）。每个样本可以拥有全部类型的一部分类型。这样的例子太普遍了，比如统计班上同学一周7天里哪天有空。每个同学都会在周一到周日这7天里，根据自己的情况分别打勾。再比如常见的博客文章分类标签，一篇文章一般都有好几个标签等等。多标签分类问题一般有两种解决方法。</p>
<p>问题转化方法(Problem transformation)可以将多标签问题转化成单标签问题。 第一种转换方法是训练集里面每个样本通过幂运算转换成单标签。比如下面数据里面每篇文章都带有若干标签。</p>
<p><img src="posts/4-from-linear-regression-to-logistic-regression/mlslpic/4.1%20multi-label.png" alt="multi-label"></p>
<p>转换方法就是用幂运算将多个类合并成一个类，比如样本1有<code>Local</code>和<code>US</code>类，新建一个标签为<code>Local^US</code>类，这样多标签就变成单标签了。</p>
<p><img src="posts/4-from-linear-regression-to-logistic-regression/mlslpic/4.2%20multi-label-power-trans.png" alt="multi-label-power-trans"></p>
<p>这样原来5个标签现在变成了7个标签。这种幂运算虽然直观，但是并不实用，因为这样做多出来的标签只有一小部分样本会用到。而且，这些标签只能在训练集里面学习这些类似，在测试集中依然无法使用。</p>
<p>另外一种问题转换方法就是每个标签都用二元分类处理。每个标签的分类器都预测样本是否属于该标签。我们的例子中需要5个二元分类器，第一个分类器预测样本是否应该被归入<code>Local</code>类，第二个分类器预测样本是否应该被归入<code>US</code>类，以此类推。预测最后一步就是把这些分类结果求并集，如下图所示。这个问题确保了单标签问题和多标签问题有同样的训练集，只是忽略了标签之间的关联关系。</p>
<p><img src="posts/4-from-linear-regression-to-logistic-regression/mlslpic/4.3%20multi-label-binary-trans.png" alt="multi-label-binary-trans"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="多标签分类效果评估">多标签分类效果评估<a class="anchor-link" href="posts/4-from-linear-regression-to-logistic-regression/#%E5%A4%9A%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB%E6%95%88%E6%9E%9C%E8%AF%84%E4%BC%B0">¶</a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>多标签分类效果评估与多标签分类效果评估方式不同。最常用的手段是汉明损失函数（Hamming loss）和杰卡德相似度（Jaccard similarity）。汉明损失函数表示错误标签的平均比例，是一个函数，当预测全部正确，即没有错误标签时，值为0。杰卡德相似度或杰卡德相指数（Jaccard index），是预测标签和真实标签的交集数量除以预测标签和真实标签的并集数量。其值在<code>{0,1}</code>之间，公式如下：</p>
$$J(Predicted,True) = \frac {|Predicted \cap True|} {|Predicted \cup True|}$$
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [39]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">hamming_loss</span><span class="p">,</span> <span class="n">jaccard_similarity_score</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hamming_loss</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]])))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hamming_loss</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]])))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hamming_loss</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]])))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">jaccard_similarity_score</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]])))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">jaccard_similarity_score</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]])))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">jaccard_similarity_score</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]])))</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>0.0
0.25
0.5
1.0
0.75
0.5
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="总结">总结<a class="anchor-link" href="posts/4-from-linear-regression-to-logistic-regression/#%E6%80%BB%E7%BB%93">¶</a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>本章我们介绍了广义线性模型，是对普通线性回归中解释变量非正态分布情况的扩展。广义线性回归模型通过联接方程将解释变量和响应变量联接起来，和普通线性回归不同，这个方程可能是非线性的。我们重点介绍了逻辑联接方程，其图象是一种S曲线，对任意实数的返回值都在在<code>{0,1}</code>之间，如群体生长曲线。</p>
<p>之后，我们介绍了逻辑回归，一种通过逻辑联接方程联接解释变量与呈伯努力分布的响应变量的关系。逻辑回归可用于解决二元分类问题，我们用它研究了典型的垃圾短信分类问题。紧接着我们介绍了多类分类问题，其类型空间超过两个，每个样本都有且仅有一种类型，我们用one-vs.-all策略研究了通过影评对电影分类的问题。最后，我们介绍了多标签分类，其类型空间超过两个，每个样本都有至少一种标签。介绍完广义线性模型的回归和分类问题，下一章我们就来介绍非线性模型的回归和分类问题——决策树。</p>

</div>
</div>
</div>
    </div>
  </div>

    </div>
    </article>
</div>
        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-5.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-3.html" rel="next">Older posts</a>
            </li>
        </ul></nav><script>var disqus_shortname="tj2";(function(){var a=document.createElement("script");a.async=true;a.src="//"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2015         <a href="mailto:muxuezi@gmail.com">Tao Junjie</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/ar/">
<img alt="Creative Commons License BY-NC-SA" style="border-width:0; margin-bottom:12px;" src="http://i.creativecommons.org/l/by-nc-sa/2.5/ar/88x31.png"></a>
            
        </footer>
</div>
</div>

            <script src="assets/js/all-nocdn.js"></script><script>$('a.image-reference:not(.islink) img:not(.islink)').parent().colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script><!-- fancy dates --><script>
    moment.locale("");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-51330059-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
</html>
